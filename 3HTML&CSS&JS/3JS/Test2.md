- ## 运算符

  - ##### 算数运算符

    > JS 共提供10个算术运算符，用来完成基本的算术运算：加减乘除、指数、求余、自增、自减、正号、负号。

    - **加减乘除：**JS 允许非数值的加减乘除，此时非数值会自动转为数值再计算。

      > 如果加号两边有一个是字符串，这时加法运算符会变成字符串连接运算符（非字符串的一边会自动转为字符串）。

      ###### 对象相加：

      > 如果运算子是对象（引用类型），此时会先转成原始类型的值，然后再相加。对象转成原始类型的值，规则如下：
      >
      > 1. 首先调用对象的`valueOf`方法。
      > 2. 如果还是对象类型，再调用对象的`toString`方法，将其转为字符串。
      >
      > 这里有一个特例，如果运算子是一个`Date`对象的实例，那么会优先执行`toString`方法。

    - **指数：**指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。功能和`Math.pow(2,10)`相同，该运算符是 ES6 的特性。

      > 注意：指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。
      >
      > ```js
      > // 相当于 2 ** (3 ** 2)
      > 2 ** 3 ** 2
      > // 512
      > ```

    - **求余：**求余数运算符（`%`）返回前一个运算子被后一个运算子除，所得的余数。需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

      > 余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。
      >
      > ```js
      > 6.5 % 2.1  // 0.19999999999999973
      > ```

    - **自增自减：**自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

      > 运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。
      >
      > 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

    - **正负号：**`+`和`-`也是一元运算符，用在数值前当作正负号来解析。它可以将任何值转为数值，与`Number`函数的作用相同。

    - **赋值：**赋值运算符用于给变量赋值。最常见的赋值运算符就是等号（`=`）。

      > 赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合：

      ```js
      // 等同于 x = x + y
      x += y
      
      // 等同于 x = x - y
      x -= y
      
      // 等同于 x = x * y
      x *= y
      
      // 等同于 x = x / y
      x /= y
      
      // 等同于 x = x % y
      x %= y
      
      // 等同于 x = x ** y
      x **= y
      ```

      > 下面是与位运算符的结合：（这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量）

      ```js
      // 等同于 x = x >> y
      x >>= y
      
      // 等同于 x = x << y
      x <<= y
      
      // 等同于 x = x >>> y
      x >>>= y
      
      // 等同于 x = x & y
      x &= y
      
      // 等同于 x = x | y
      x |= y
      
      // 等同于 x = x ^ y
      x ^= y
      ```

  - ##### 比较运算符

    > 比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。注意，比较运算符可以比较各种类型的值，不仅仅是数值。
    >
    > JavaScript 一共提供了8个比较运算符。
    >
    > - `>` 大于运算符
    > - `<` 小于运算符
    > - `<=` 小于或等于运算符
    > - `>=` 大于或等于运算符
    > - `==` 相等运算符
    > - `===` 严格相等运算符
    > - `!=` 不相等运算符
    > - `!==` 严格不相等运算符
    >
    > 这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的。

    - **非相等比较：**对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，去比较数值的大小。
    - **相等比较：**JS 提供两种相等运算符：`==`和`===`。它们的区别是相等运算符（`==`）会做自动类型转换。如果两个值不是同一类型，严格相等运算符（`===`）直接返回`false`，而相等运算符（`==`）会将它们转换成同一个类型，再用严格相等运算符进行比较。

  - ##### 布尔运算符

    > 布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

    - 取反运算符（`!`）：取反运算符用于将布尔值变为相反值，即`true`变成`false`，`false`变成`true`。对于非布尔值，取反运算符会将其转为布尔值再取反。

      > 如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与`Boolean`函数的作用相同。这是一种常用的类型转换的写法。

    - 且运算符（`&&`）以及或运算符（`||`）：用于多个表达式的求值，它们都可以多个连用。

      - 且运算符（`&&`）的运算规则是：如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值（短路）。

      - 或运算符（`||`）的运算规则是：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。（短路规则对这个运算符也适用）

        > 或运算符常用于为一个变量设置默认值：`var a = flag || '';`

    - 三元运算符（`?:`）：三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为`true`，则返回第二个表达式的值，否则返回第三个表达式的值。

  - ##### 位运算符

    > 位运算符用于直接对二进制位进行计算，一共有7个：
    >
    > - **二进制或运算符**（or）：符号为`|`，表示若两个二进制位都为`0`，则结果为`0`，否则为`1`。
    >
    > - **二进制与运算符**（and）：符号为`&`，表示若两个二进制位都为1，则结果为1，否则为0。
    >
    > - **二进制否运算符**（not）：符号为`~`，表示对每一个二进制位取反。
    >
    >   > - 对一个小数连续进行两次二进制否运算，能达到取整效果。这是所有取整方法中最快的一种。
    >   > - 对非数字型进行二进制否运算，JS 引擎会先调用`Number`函数，将字符串转为数值。
    >
    > - **异或运算符**（xor）：符号为`^`，表示若两个二进制位不相同，则结果为1，否则为0。
    >
    >   > “异或运算”有一个特殊运用，连续对两个数`a`和`b`进行3次异或运算，`a^=b; b^=a; a^=b;`，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。这是互换两个变量的值的最快方法。
    >
    > - **算数左移运算符**：符号为`<<`，将一个数的二进制值向左移动指定的位数，尾部补`0`，即乘以`2`的指定次方。
    >
    > - **算数右移运算符**：符号为`>>`，将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补`0`；如果是负数，头部全部补`1`。右移运算符基本上相当于除以`2`的指定次方（最高位即符号位参与移动）。
    >
    > - **逻辑右移运算符**：符号为`>>>`，它和算数右移运算符的区别是，向右移动时，头部一律补零，不考虑符号位。所以，该运算总是得到正值。对于正数，该运算的结果与右移运算符（`>>`）完全一致，区别主要在于负数。
    >
    >   > 查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符。
    >   >
    >   > ```js
    >   > -1 >>> 0 // 4294967295
    >   > ```
    >   >
    >   > 上面代码表示，`-1`作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即`(2^32)-1`，等于`11111111111111111111111111111111`）。
    >
    > 这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。
    >
    > 有一点需要特别注意，位运算符只对整数起作用，**如果一个运算子不是整数，会自动转为整数后再执行**。另外，虽然在 JS 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。利用这个特性，可以写出一个函数，将任意数值转为32位整数：
    >
    > ```js
    > function toInt32(x) {
    > 	return x | 0;
    > }
    > ```
    >
    > 其他位运算符也可以做到。但是需要注意，这种取整方法不适用超过32位整数最大值2147483647的数。

    ###### 开关作用：

    > 位运算符可以用作设置对象属性的开关。
    >
    > 假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。
    >
    > ```js
    > var FLAG_A = 1; // 0001
    > var FLAG_B = 2; // 0010
    > var FLAG_C = 4; // 0100
    > var FLAG_D = 8; // 1000
    > ```
    >
    > 上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位。
    >
    > 然后，就可以用二进制与运算，检查当前设置是否打开了指定开关。
    >
    > ```js
    > var flags = 5; // 二进制的0101
    > 
    > if (flags & FLAG_C) {
    >   // ...
    > }
    > // 0101 & 0100 => 0100 => true
    > ```
    >
    > 上面代码检验是否打开了开关`C`。如果打开，会返回`true`，否则返回`false`。
    >
    > 现在假设需要打开`A`、`B`、`D`三个开关，我们可以构造一个掩码变量。
    >
    > ```js
    > var mask = FLAG_A | FLAG_B | FLAG_D;
    > // 0001 | 0010 | 1000 => 1011
    > ```
    >
    > 上面代码对`A`、`B`、`D`三个变量进行二进制或运算，得到掩码值为二进制的`1011`。
    >
    > 有了掩码，二进制或运算可以确保打开指定的开关。
    >
    > ```js
    > flags = flags | mask;
    > ```
    >
    > 上面代码中，计算后得到的`flags`变量，代表三个开关的二进制位都打开了。
    >
    > 二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。
    >
    > ```js
    > flags = flags & mask;
    > ```
    >
    > 异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。
    >
    > ```js
    > flags = flags ^ mask;
    > ```
    >
    > 二进制否运算可以翻转当前设置，即原设置为`0`，运算后变为`1`；原设置为`1`，运算后变为`0`。
    >
    > ```js
    > flags = ~flags;
    > ```

  - ##### 其他运算符

    - `void` 运算符：`void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。用法：`void 表达式;`或`void(表达式);`。

      > 实现**无用链接**：
      >
      > ```html
      > <script>
      > function f() {
      > 	console.log('Hello World');
      > }
      > </script>
      > <a href="http://example.com" onclick="f(); return false;">点击</a>
      > ```
      >
      > 上面代码中，点击链接后，会先执行`onclick`的代码，由于`onclick`返回`false`，所以浏览器不会跳转到 example.com。`void`运算符可以取代上面的写法。
      >
      > ```html
      > <a href="javascript: void(f())">文字</a>
      > ```
      >
      > 如果不需要执行任何操作，`href`中可以写：
      >
      > - `javascript:void(0);`
      > - `javascript:;`
    
    - 逗号运算符（`,`）：逗号运算符用于对两个表达式求值，并返回后一个表达式的值。
    
      ```js
      'a', 'b' // "b"
      var x = 0;
      var y = (x++, 10);
      x // 1
      y // 10
      ```
    
      > 逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作。
    
    - 圆括号`()`：它只有两个作用，一个是用于调用函数；另一个是用于提高运算的优先级，此时里面只能放表达式。

- ## 语法专题

  - #### 数据类型的转换

    > JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。变量的类型没法在编译阶段就知道，必须等到运行时才能知道。虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的。如果运算符发现，运算子的类型与预期不符，就会自动转换类型。比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值。
    >
    > 这里讲解下数据的自动类型转换规则。在此之前，先讲解如何进行强制数据类型转换。

    - ##### 强制类型转换：

      > 强制转换主要指，使用`Number()`、`String()`和`Boolean()`三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。

      - `Number()`：`Number`函数可以将任意类型的值转化成数字，转换规则如下。

        > 原始类型值的转换规则如下：
        >
        > ```js
        > // 数值：转换后还是原来的值
        > Number(324) // 324
        > 
        > // 字符串：如果可以被解析为数值，则转换为相应的数值
        > Number('324') // 324
        > 
        > // 字符串：如果不可以被解析为数值，返回 NaN
        > Number('324abc') // NaN
        > 
        > // 空字符串转为0
        > Number('') // 0
        > 
        > // 布尔值：true 转成 1，false 转成 0
        > Number(true) // 1
        > Number(false) // 0
        > 
        > // undefined：转成 NaN
        > Number(undefined) // NaN
        > 
        > // null：转成0
        > Number(null) // 0
        > ```
        >
        > `Number`函数将字符串转为数值，要比`parseInt`函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`。另外，`parseInt`和`Number`函数都会自动过滤一个字符串前导和后缀的空格。

        > 对象类型：
        >
        > 简单的规则是，`Number`方法的参数是对象时，将返回`NaN`，除非是包含单个数值的数组，如`[5]`。之所以会这样，是因为`Number`背后的转换规则比较复杂：
        >
        > 1. 调用对象自身的`valueOf`方法。如果返回原始类型的值，则直接对该值使用`Number`函数，不再进行后续步骤。
        > 2. 如果`valueOf`方法返回的还是对象，则改为调用对象自身的`toString`方法。如果`toString`方法返回原始类型的值，则对该值使用`Number`函数，不再进行后续步骤。
        > 3. 如果`toString`方法返回的是对象，就报错。

      - `String()`：`String`函数可以将任意类型的值转化成字符串，转换规则如下。

        > 原始类型：
        >
        > - **数值**：转为相应的字符串。
        > - **字符串**：转换后还是原来的值。
        > - **布尔值**：`true`转为字符串`"true"`，`false`转为字符串`"false"`。
        > - **undefined**：转为字符串`"undefined"`。
        > - **null**：转为字符串`"null"`。
        >
        > 对象类型：
        >
        > `String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。
        >
        > ```js
        > String({a: 1}) // "[object Object]"
        > String([1, 2, 3]) // "1,2,3"
        > ```
        >
        > `String`方法背后的转换规则，与`Number`方法基本相同，只是互换了`valueOf`方法和`toString`方法的执行顺序。
        >
        > 1. 先调用对象自身的`toString`方法。如果返回原始类型的值，则对该值使用`String`函数，不再进行以下步骤。
        > 2. 如果`toString`方法返回的是对象，再调用原对象的`valueOf`方法。如果`valueOf`方法返回原始类型的值，则对该值使用`String`函数，不再进行以下步骤。
        > 3. 如果`valueOf`方法返回的是对象，就报错。

      - `Boolean()`：`Boolean()`函数可以将任意类型的值转为布尔值。这个不再细说，前面说过了。

    - ##### 自动类型转换：

      > 自动类型转换是以强制转换为基础的。遇到以下几种情况时，JS 会进行自动类型转换：
      >
      > 1. 不同类型的数据互相运算。
      > 2. 对非布尔值类型的数据求布尔值。
      > 3. 对非数值类型的值使用一元运算符（即`+`和`-`）。
      > 4. 当通过原始类型值调用其对应的包装对象原型上的方法时，原始类型会先自动转为对应的包装对象再调用。
      >
      > 自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用`String()`函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值。
      >
      > 由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用`Boolean()`、`Number()`和`String()`函数进行显式转换。
  
  - #### JS 的错误处理机制
  
    > JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。
    >
    > ```
    > var err = new Error('出错了');
    > err.message // "出错了"
    > ```
    >
    > `Error()`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。当使用`throw`关键字抛出`Error`实例后，整个程序就中断在发生错误的地方，不再往下执行。
    >
    > JavaScript 语言标准只提到，`Error`实例对象必须有`message`属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。
    >
    > - **message**：错误提示信息
    > - **name**：错误名称（非标准属性）
    > - **stack**：错误的堆栈（非标准属性）
    >
    > `Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在`Error`的6个子类型对象。
  
    - `SyntaxError` 对象：解析代码时发生的语法错误。
  
    - `ReferenceError` 对象：引用一个不存在的变量时发生的错误。
  
      > 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。
      >
      > ```js
      > // 等号左侧不是变量
      > console.log() = 1
      > // Uncaught ReferenceError: Invalid left-hand side in assignment
      > ```
  
    - `RangeError` 对象：一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。
  
    - `TypeError` 对象：变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。
  
    - `URIError` 对象：URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。
  
    - `EvalError` 对象：`eval`函数没有被正确执行时抛出的错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。
  
    > 以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。
  
    ###### 自定义错误：
  
    > 除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。
    >
    > ```js
    > function UserError(message) {
    >        this.message = message || '默认信息';
    >        this.name = 'UserError';
    > }
    > UserError.prototype = new Error();
    > UserError.prototype.constructor = UserError;
    > ```
    >
    > 上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。
  
    ###### `throw` 语句：
  
    > `throw`语句的作用是手动中断程序执行，并抛出一个错误。语法：`throw 值;`。
    >
    > 实际上，`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。
    >
    > 对于 JavaScript 引擎来说，遇到`throw`语句，程序就中止了。引擎会接收到`throw`抛出的信息，可能是一个错误实例，也可能是其他类型的值。
  
    ###### `try{}catch(){}` 结构：
  
    > 一旦发生错误，程序就中止执行了。JS 提供了`try{}catch(){}`结构，允许对错误进行处理，选择是否往下执行。
    >
    > ```js
    > try {
    > 	throw new Error('出错了!');
    > } catch (e) {
    >    console.log(e.name + ": " + e.message);
    >    console.log(e.stack);
    > }
    > // Error: 出错了!
    > //   at <anonymous>:3:9
    > //   ...
    > ```
    >
    > 上面`try`代码块中，如果代码运行出现了错误（无论是手动抛出错误还是运行错误），JS 引擎就立即把代码的执行转到`catch`代码块中，或者说错误被`catch`代码块捕获了。`catch`接受一个参数，表示`try`代码块抛出的值。
    >
    > 如果你不确定某些代码是否会报错，就可以把它们放在`try...catch`代码块之中，便于进一步对错误进行处理。
    >
    > `catch`代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。
    >
    > `catch`代码块之中，还可以再抛出错误，甚至使用嵌套的`try...catch`结构。
    >
    > **注意：**try{}中的异步任务发生异常catch()是捕获不到的。因此，**开发者应避免使用Try Catch捕获由异步任务引发的错误**。
  
    ###### `finally` 代码块：
    
    > `try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后执行的语句。
    >
    > 即使`try`代码块里面还包括`return`语句，`finally`代码块最后依然会执行。（finally块在return之后执行）
    
  - #### 全局对象`console`
  
    > `console`对象是 JS 的原生对象，它有点像 Unix 系统的标准输出`stdout`和标准错误`stderr`，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。`console`的常见用途有两个：
    >
    > - 调试程序，显示网页代码运行时的错误信息。
    > - 提供了一个命令行接口，用来与网页代码互动。
    >
    > `console`对象的浏览器实现，包含在浏览器自带的开发工具之中（F12）。`console`对象提供的各种静态方法，用来与控制台窗口互动。
    >
    > `console`对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义`console.log`方法。
  
    - `console.log()`：用于在控制台输出信息。它可以接受一个或多个参数，将它们用空格连接起来输出。它会自动在每次输出的结尾添加换行符。
  
      > 如果第一个参数是格式字符串（使用了格式占位符），`console.log`方法将依次用后面的参数替换占位符，然后再进行输出。
      >
      > ```js
      > console.log('%s + %s = %s', 1, 1, 2)  // 1 + 1 = 2
      > ```
      >
      > `console.log`方法支持以下占位符，不同类型的数据必须使用对应的占位符。
      >
      > - `%s` 字符串
      > - `%d` 整数
      > - `%i` 整数
      > - `%f` 浮点数
      > - `%o` 对象的链接
      > - `%c` CSS 格式字符串
      >
      > 使用`%c`占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。
      >
      > ```js
      > console.log(
      >     '%cThis text is styled!',
      >     'color: red; background: yellow; font-size: 24px;'
      > )
      > ```
      >
      > 上面代码运行后，输出的内容将显示为黄底红字。
  
    - `console.info()`：它是`console.log`方法的别名，用法完全一样。只不过`console.info`方法会在输出信息的前面，加上一个蓝色图标。
  
    - `console.debug()`：`console.debug`方法与`console.log`方法类似，会在控制台输出调试信息。但是，默认情况下，`console.debug`输出的信息不会显示，只有在打开显示级别在`verbose`的情况下，才会显示。
  
    - `console.warn()`和`console.error()`：`warn`方法和`error`方法也是在控制台输出信息，它们与`log`方法的不同之处在于，`warn`方法输出信息时，在最前面加一个黄色三角，表示警告；`error`方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。
  
    - `console.table()`：对于某些复合类型的数据，`console.table`方法可以将其转为表格显示。
  
    - `console.count()`：`count`方法用于计数，输出它被调用了多少次。该方法可以接受一个字符串作为作为标签，根据字符串的不同对执行次数进行分类。
  
    - `console.dir()`：以**交互式列表**的形式显示一个对象的属性和方法，方便开发者检查和调试对象的结构进行检查，并以易于阅读和打印的格式显示。该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。Node 环境之中，还可以指定以代码高亮的形式输出：`console.dir(obj, {colors: true})`
  
    - `console.dirxml()`：用于以目录树的形式，显示 DOM 节点。如果参数不是 DOM 节点，而是普通的 JS 对象，`console.dirxml`等同于`console.dir`。
  
    - `console.assert()`：用于在程序运行过程中进行条件判断，如果不满足条件就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。它接受两个参数，第1个参数是表达式，第2个参数是字符串。只有当第1个参数为`false`时，才会在控制台输出第2个参数，否则不会显示任何内容。
  
    - `console.time()`和`console.timeEnd()`：这两个方法用于计时，可以算出一个操作所花费的准确时间。`time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。注意：开始和结束方法的参数要保持一致。
  
    - `console.group()`、`console.groupEnd()`、`console.groupCollapsed()`：`group`和`groupEnd`这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。
  
      ```js
      console.group('一级分组');
      console.log('一级分组的内容');
      
      console.group('二级分组');
      console.log('二级分组的内容');
      
      console.groupEnd(); // 二级分组结束
      console.groupEnd(); // 一级分组结束
      ```
  
      > 上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。
      >
      > `groupCollapsed`方法与`group`方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。
  
    - `console.trace()`：显示当前执行的代码在堆栈中的调用路径。
  
    - `console.clear()`：清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，该方法将不起作用。
  
  - #### `debugger` 语句
  
    > `debugger`语句作用是设置断点，主要用于排错。如果有正在运行的排错工具，程序运行到`debugger`语句时会自动停下。如果没有除错工具，`debugger`语句不会产生任何结果，JS 引擎自动跳过这一句。
    >
    > Chrome 浏览器中打开F12时，当代码运行到`debugger`语句时，就会暂停运行，自动打开脚本源码界面。
  
- ## 面向对象编程

  > JavaScript 语言具有很强的面向对象编程能力，本章介绍 JavaScript 面向对象编程的基础知识。

  - ### 对象和构造函数

    - 面向对象编程：

      > 面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。
      >
      > 每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。
      >
      > 那么，“对象”（object）到底是什么？我们从两个层次来理解：
      >
      > 1. **对象是单个实物的抽象。**
      >
      >    一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。
      >
      > 2. **对象是一个容器，封装了属性（property）和方法（method）。**
      >
      >    属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为`animal`对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。

    - 构造函数：

      > 面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。
      >
      > 典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是 JS 的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。
      >
      > JS 使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。
      >
      > 构造函数就是一个普通的函数，但具有自己的特征和用法：
      >
      > ```js
      > var Vehicle = function () {
      > 	this.price = 1000;
      > };
      > ```
      >
      > 上面代码中，`Vehicle`就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。
      >
      > 构造函数的特点有两个：
      >
      > - 函数体内部使用了`this`关键字，代表了所要生成的对象实例。
      > - 调用构造函数生成对象的时候，必须使用`new`命令调用。
      >
      > 下面先介绍`new`命令。

    - `new` 命令：

      > `new`命令的作用，就是调用构造函数并返回一个实例对象。
      >
      > ```js
      >var Vehicle = function () {
      > 	this.price = 1000;
      > };
      >   var v = new Vehicle();
      > v.price // 1000
      > ```
      > 
      > 上面代码通过`new`命令，让构造函数`Vehicle`生成一个实例对象，保存在变量`v`中。这个新生成的实例对象，从构造函数`Vehicle`得到了`price`属性。`new`命令执行时，构造函数内部的`this`就指向了新生成的实例对象，`this.price`用于给实例对象添加一个`price`属性，值是1000。
      > 
      >使用`new`命令时，根据需要，构造函数也可以接受参数。
      > 
      >`new`命令本身就可以执行构造函数，所以后面的构造函数如果不传参数可以带括号，也可以不带括号。推荐带上括号。

      ###### 一个很自然的问题是，如果忘了使用`new`命令，直接调用构造函数会发生什么事？

      > 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，`this`这时指向全局对象window，这会造成一些意想不到的结果。
      >
      > ```js
      >var Vehicle = function (){
      > 	this.price = 1000;
      > };
      >   var v = Vehicle();
      > v // undefined
      > price // 1000
      > ```
      > 
      > 上面代码中，调用`Vehicle`构造函数时，忘了加上`new`命令。结果，变量`v`变成了`undefined`，而`price`属性变成了全局变量。因此，应该非常小心，避免不使用`new`命令、直接调用构造函数。
      >
      > **为了保证构造函数必须与`new`命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上`use strict`。这样的话，一旦忘了使用`new`命令，直接调用构造函数就会报错。**
      >
      > ```js
      >function Fubar(foo, bar){
      >     'use strict';
      >     this._foo = foo;
      >   	this._bar = bar;
      > }
      > Fubar()  // TypeError: Cannot set property '_foo' of undefined
      > ```
      > 
      >上面代码的`Fubar`为构造函数，`use strict`命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的`this`不能指向全局对象，默认等于`undefined`，导致不加`new`调用会报错（JS 不允许对`undefined`添加属性）。
      > 
      >另一个解决办法，构造函数内部判断是否使用`new`命令，如果发现没有使用，则直接返回一个实例对象。
      > 
      > ```js
      > function Fubar(foo, bar) {
      >     if (!(this instanceof Fubar)) {
      >     	return new Fubar(foo, bar);
      > 	}
      >
      >     this._foo = foo;
      >    this._bar = bar;
      > }
      >Fubar(1, 2)._foo // 1
      > (new Fubar(1, 2))._foo // 1
      > ```
      >   
      > 上面代码中的构造函数，不管加不加`new`命令，都会得到同样的结果。

    - `new` 命令的原理：

      > 使用`new`命令时，它后面的函数依次执行下面的步骤：
      >
      > 1. 创建一个空对象，作为将要返回的对象实例。
      >2. 将这个空对象的原型（`__proto__`），指向构造函数的`prototype`属性。
      > 3. 将内部的`this`关键字指向这个空对象。
      > 4. 开始执行构造函数内部的代码。
      >   
      > 也就是说，构造函数内部，`this`指的是一个新生成的空对象，所有针对`this`的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即`this`对象），将其“构造”为需要的样子。
      > 
      > 如果构造函数内部有`return`语句，而且`return`后面跟着一个对象，`new`命令会返回`return`语句指定的对象；否则，就会不管`return`语句，返回`this`指向的这个对象。

      ###### `new`命令简化的内部流程，可以用下面的代码表示：

      ```js
      function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {
          // 将 arguments 对象转为数组
          var args = [].slice.call(arguments);
          // 取出构造函数
          var constructor = args.shift();
          // 创建一个空对象，继承构造函数的 prototype 属性
          var context = Object.create(constructor.prototype);
          // 执行构造函数
          var result = constructor.apply(context, args);
          // 如果返回结果是对象，就直接返回，否则返回 context 对象
          return (typeof result === 'object' && result != null) ? result : context;
      }
      // 实例
      var actor = _new(Person, '张三', 28);
      ```

      > **函数中的`new.target`属性：**函数内部可以使用`new.target`属性。如果当前函数是`new`命令调用，`new.target`指向当前函数，否则为`undefined`。（箭头函数中没有该属性）

  - ### `this` 关键字

    > 环境对象`this`是函数内部的一个特殊变量（箭头函数没有this），代表了当前函数运行时所在的上下文环境。不同环境下`this`的指向不同。那怎么看this指向谁呢？
    >
    > 谁调用的该函数，函数中的`this`指向谁。
    >
    > `this`指向调用这个函数的对象。全局作用域中调用的函数，`this`指向全局作用域的`window`对象。回调函数中的this通常指向该函数所在的作用域。箭头函数中没有`this`，它继承了上个作用域的`this`。
    >
    > （回调函数中的`this`往往会改变指向，最好避免使用。因此很多回调函数都写成箭头函数）

    ###### `this`的动态切换，固然为 JS 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把`this`固定下来，避免出现意想不到的情况。JS 提供了`call`、`apply`、`bind`这三个方法，来切换/固定`this`的指向：

    1. `fnc.call(thisObj, 函数参数..)`：它会调用fnc函数，并将函数中的`this`指向第1个参数。

       > 注意：
       >
       > 1. 第1个参数应该是一个对象，如果参数为`null`或`undefined`，则默认传入全局对象window。
       > 2. 如果第1个参数是一个原始值，那么这个原始值会自动转成对应的包装对象。

       ###### `call`方法的一个应用是调用对象的原生方法：

       ```js
       var obj = {};
       obj.hasOwnProperty('toString') // false
       
       // 覆盖掉继承的 hasOwnProperty 方法
       obj.hasOwnProperty = function () {
         return true;
       };
       obj.hasOwnProperty('toString') // true
       
       Object.prototype.hasOwnProperty.call(obj, 'toString') // false
       ```

       > 上面代码中，`hasOwnProperty`是`obj`对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。`call`方法可以解决这个问题，它将`hasOwnProperty`方法的原始定义放到`obj`对象上执行，这样无论`obj`上有没有同名方法，都不会影响结果。

    2. `fnc.apply(thisObj, 数组)`：和`call()`函数类似，只不过函数参数放在了数组中。

       > - 比如求数组最大值可以：`Math.max.apply(null, arr)`
       >
       > - 将数组的空位元素变为`undefined`：`Array.apply(null, ['a', ,'b'])`
       >
       >   > 空元素与`undefined`的差别在于，数组的`forEach`方法会跳过空元素，但是不会跳过`undefined`。因此，遍历内部元素的时候，会得到不同的结果。
       >
       > - 将伪数组转为数组：`Array.prototype.slice.apply({0: 1, length: 1}) // [1]`
       >
       >   > 这个方法起作用的前提是，被处理的对象必须有`length`属性，以及相对应的数字键。

    3. `fnc.bind(thisObj, 函数的预设参数..)`：它改变函数的`this`后返回一个新函数。后面的参数用于给函数预设实参。

    ###### `this`的本质：

    > 其实`this`本质上就是函数运行时所在的环境，JS 语言之所以有 this 的设计，跟内存里面的数据结构有关系。
    >
    > ```js
    > var obj = { foo:  5 };
    > ```
    >
    > 上面的代码将一个对象赋值给变量`obj`。JavaScript 引擎会先在内存里面，生成一个对象`{ foo: 5 }`，然后把这个对象的内存地址赋值给变量`obj`。也就是说，变量`obj`是一个地址（reference）。后面如果要读取`obj.foo`，引擎先从`obj`拿到内存地址，然后再从该地址读出原始的对象，返回它的`foo`属性。
    >
    > 原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的`foo`属性，实际上是以下面的形式保存的。
    >
    > ```js
    > {
    >     foo: {
    >         [[value]]: 5
    >         [[writable]]: true
    >         [[enumerable]]: true
    >         [[configurable]]: true
    >     }
    > }
    > ```
    >
    > 注意，`foo`属性的值保存在属性描述对象的`value`属性里面。
    >
    > 这样的结构是很清晰的，问题在于属性的值可能是一个函数。
    >
    > ```js
    > var obj = { foo: function () {} };
    > ```
    >
    > 这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给`foo`属性的`value`属性。
    >
    > ```js
    > {
    >     foo: {
    >         [[value]]: 函数的地址
    >         ...
    >     }
    > }
    > ```
    >
    > 由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。
    >
    > ```js
    > var f = function () {};
    > var obj = { f: f };
    > 
    > // 单独执行
    > f()
    > 
    > // obj 环境执行
    > obj.f()
    > ```
    >
    > JavaScript 允许在函数体内部，引用当前环境的其他变量。
    >
    > ```js
    > var f = function () {
    > 	console.log(x);
    > };
    > ```
    >
    > 上面代码中，函数体里面使用了变量`x`。该变量由运行环境提供。
    >
    > 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，`this`就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。
    >
    > ```js
    > var f = function () {
    > 	console.log(this.x);
    > }
    > ```
    >
    > 上面代码中，函数体里面的`this.x`就是指当前运行环境的`x`。
    >
    > ```js
    > var f = function () {
    > 	console.log(this.x);
    > }
    > 
    > var x = 1;
    > var obj = {
    >     f: f,
    >     x: 2,
    > };
    > 
    > // 单独执行
    > f() // 1
    > 
    > // obj 环境执行
    > obj.f() // 2
    > ```
    >
    > 上面代码中，函数`f`在全局环境执行，`this.x`指向全局环境的`x`；在`obj`环境执行，`this.x`指向`obj.x`。

  - ### JS 中的原型继承

    > 面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。
    >
    > 大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JS 语言的继承不通过类，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型继承。
    >
    > （ES6 引入了 class 语法，基于 class 的继承不在这里介绍，请参考ES6笔记。不过它本质上就是原型继承的语法糖而已）

    - ##### 构造函数的缺点：

      > 通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。
      >
      > ```js
      > function Cat(name, color) {
      >     this.name = name;
      >     this.color = color;
      >     this.meow = function () {
      >     	console.log('喵喵');
      >     };
      > }
      > 
      > var cat1 = new Cat('大毛', '白色');
      > var cat2 = new Cat('二毛', '黑色');
      > 
      > cat1.meow === cat2.meow  // false
      > ```
      >
      > 上面代码中，`cat1`和`cat2`是同一个构造函数的两个实例，它们都具有`meow`方法。由于`meow`方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个`meow`方法。这既没有必要，又浪费内存，因为所有`meow`方法都是同样的行为，完全应该共享。
      >
      > 这个问题的解决方法，就是 JS 的原型对象（prototype）。

    - ##### 原型对象（prototype）：

      > 原型对象就是一个包含了`constructor`属性的普通对象而已。
      >
      > JS 继承的设计思想是：将需要被所有实例共享的属性和方法，放在原型对象上。所有实例都能访问到它们共同的原型对象上的属性和方法。具体的实现为：
      >
      > - 首先，JS中的**每个函数都有一个`prototype`属性**，指向一个原型对象。（箭头函数、简写的对象方法、异步函数中没有`prototype`属性）
      >
      > - 当实例对象本身没有某个属性或方法的时候，它会到自己所关联的原型对象上去找该属性或方法。如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。这就是原型对象的特殊之处。
      >
      >   > 实例对象的`__proto__`指向该实例所关联的原型对象。
      >
      > 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在**所有**实例对象上。

    - ##### 原型链：

      > JS 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……
      >
      > 如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`上的成员。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的。
      >
      > 那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`。`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是`null`。
      >
      > 读取对象的某个属性时，JS 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的`Object.prototype`还是找不到，则返回`undefined`。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。

      ###### 注意：一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。

    - ##### `constructor` 属性：

      > 原型对象有一个`constructor`属性，默认指向原型对象所在的构造函数。
      >
      > 由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。因此每个实例可以通过原型上的`constructor`来访问构造该实例的构造函数。
      >
      > 另一方面，有了`constructor`属性，就可以从一个实例对象新建另一个实例。
      >
      > ```js
      > function Constr() {}
      > var x = new Constr();
      > var y = new x.constructor();
      > y instanceof Constr // true
      > ```
      >
      > 上面代码中，`x`是构造函数`Constr`的实例，可以从`x.constructor`间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。
      >
      > ```js
      > Constr.prototype.createCopy = function () {
      > 	return new this.constructor();
      > };
      > ```
      >
      > `constructor`属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改`constructor`属性，防止引用的时候出错。
      >
      > ```js
      > function Person(name) {
      > 	this.name = name;
      > }
      > Person.prototype.constructor === Person // true
      > Person.prototype = {
      > 	method: function () {}
      > };
      > Person.prototype.constructor === Person // false
      > Person.prototype.constructor === Object // true
      > ```
      >
      > 上面代码中，构造函数`Person`的原型对象改掉了，但是没有修改`constructor`属性，导致这个属性不再指向`Person`。由于`Person`的新原型是一个普通对象，而普通对象的`constructor`属性指向`Object`构造函数，导致`Person.prototype.constructor`变成了`Object`。
      >
      > 所以，修改原型对象时，一般要同时修改`constructor`属性的指向。
      >
      > ```js
      > // 坏的写法
      > C.prototype = {
      >   method1: function (...) { ... },
      >   // ...
      > };
      > 
      > // 好的写法
      > C.prototype = {
      >   constructor: C,
      >   method1: function (...) { ... },
      >   // ...
      > };
      > 
      > // 更好的写法
      > C.prototype.method1 = function (...) { ... };
      > ```
      >
      > 上面代码中，要么将`constructor`属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证`instanceof`运算符不会失真。

    - ##### `instanceof` 运算符：

      > `instanceof`运算符返回一个布尔值，表示对象是否为某个构造函数的实例。
      >
      > ```js
      > var v = new Vehicle();
      > v instanceof Vehicle // true
      > ```
      >
      > `instanceof`运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。
      >
      > ```js
      > v instanceof Vehicle
      > // 等同于
      > Vehicle.prototype.isPrototypeOf(v)
      > ```
      >
      > 上面代码中，`Vehicle`是对象`v`的构造函数，它的原型对象是`Vehicle.prototype`，`isPrototypeOf()`方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。

      > **注意：`instanceof`运算符只能用于对象，不适用原始类型的值。**
      >
      > ```js
      > var s = 'hello';
      > s instanceof String // false
      > ```
      >
      > 上面代码中，字符串不是`String`对象的实例（因为字符串不是对象），所以返回`false`。
      >
      > 此外，对于`undefined`和`null`，`instanceof`运算符总是返回`false`。

      > 由于`instanceof`检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回`true`。
      >
      > 除了`null`，任意对象都是`Object`的实例，所以`instanceof`运算符可以判断一个值是否为非`null`的对象。
      >
      > `instanceof`的原理是检查右边构造函数的`prototype`属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有`null`对象。这时，`instanceof`判断会失真：
      >
      > ```js
      > var obj = Object.create(null);
      > typeof obj // "object"
      > obj instanceof Object // false
      > ```
      >
      > 上面代码中，`Object.create(null)`返回一个新对象`obj`，它的原型是`null`（`Object.create()`的详细介绍见后文）。右边的构造函数`Object`的`prototype`属性，不在左边的原型链上，因此`instanceof`就认为`obj`不是`Object`的实例。这是唯一的`instanceof`运算符判断会失真的情况（一个对象的原型是`null`）。

      > `instanceof`运算符的一个用处，是判断值的类型。
      >
      > ```js
      > var x = [1, 2, 3];
      > var y = {};
      > x instanceof Array // true
      > y instanceof Object // true
      > ```
      >
      > 上面代码中，`instanceof`运算符判断，变量`x`是数组，变量`y`是对象。

      > 利用`instanceof`运算符，还可以巧妙地解决，调用构造函数时，忘了加`new`命令的问题。
      >
      > ```
      > function Fubar (foo, bar) {
      >   if (this instanceof Fubar) {
      >     this._foo = foo;
      >     this._bar = bar;
      >   } else {
      >     return new Fubar(foo, bar);
      >   }
      > }
      > ```
      >
      > 上面代码使用`instanceof`运算符，在函数体内部判断`this`关键字是否为构造函数`Fubar`的实例。如果不是，就表明忘了加`new`命令。

    - ##### 构造函数的继承：

      > 让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现：
      >
      > 1. 在子类的构造函数中，调用父类的构造函数。
      >
      >    ```js
      >    function Sub(value) {
      >        Super.call(this);
      >        this.prop = value;
      >    }
      >    ```
      >
      > 2. 让子类的原型指向父类原型创建的实例，这样子类就可以继承父类。
      >
      >    ```js
      >    Sub.prototype = Object.create(Super.prototype);
      >    Sub.prototype.constructor = Sub;
      >    Sub.prototype.method = '...';
      >    ```
      >
      >    上面代码中，`Sub.prototype`是子类的原型，要将它赋值为`Object.create(Super.prototype)`，而不是直接等于`Super.prototype`。否则后面两行对`Sub.prototype`的操作，会连父类的原型`Super.prototype`一起修改掉。
      >
      > 另外一种写法是`Sub.prototype`等于一个父类实例：
      >
      > ```js
      > Sub.prototype = new Super();
      > ```
      >
      > 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。

      举例来说，下面是一个`Shape`构造函数。

      ```js
      function Shape() {
        this.x = 0;
        this.y = 0;
      }
      
      Shape.prototype.move = function (x, y) {
        this.x += x;
        this.y += y;
        console.info('Shape moved.');
      };
      ```

      我们需要让`Rectangle`构造函数继承`Shape`。

      ```js
      // 第一步，子类继承父类的实例
      function Rectangle() {
        Shape.call(this); // 调用父类构造函数
      }
      // 另一种写法
      function Rectangle() {
        this.base = Shape;
        this.base();
      }
      
      // 第二步，子类继承父类的原型
      Rectangle.prototype = Object.create(Shape.prototype);
      Rectangle.prototype.constructor = Rectangle;
      ```

      ###### 多重继承：

      > JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。
      >
      > ```js
      > function M1() {
      >   this.hello = 'hello';
      > }
      > 
      > function M2() {
      >   this.world = 'world';
      > }
      > 
      > function S() {
      >   M1.call(this);
      >   M2.call(this);
      > }
      > 
      > // 继承 M1
      > S.prototype = Object.create(M1.prototype);
      > // 继承链上加入 M2
      > Object.assign(S.prototype, M2.prototype);
      > 
      > // 指定构造函数
      > S.prototype.constructor = S;
      > 
      > var s = new S();
      > s.hello // 'hello'
      > s.world // 'world'
      > ```
      >
      > 上面代码中，子类`S`同时继承了父类`M1`和`M2`。这种模式又称为 Mixin（混入）。

    - ##### JS 的模块化：

      > 随着网站逐渐变成“互联网应用程序”，嵌入网页的 JS 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。
      >
      > JS 的模块化编程已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。
      >
      > 但是，JS 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，利用对象实现模块的效果。

      ###### 模块：

      > **模块是实现特定功能的一组属性和方法的封装**。因此最简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面：
      >
      > ```js
      > var module1 = {
      >     _count : 0,
      >     m1 : function (){
      >     	//...
      >     },
      >     m2 : function (){
      >     	//...
      >     }
      > };
      > ```
      >
      > 上面的函数`m1`和`m2`，都封装在`module1`对象里。使用的时候，就是调用这个对象的属性。
      >
      > 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写，这里外部就能直接改内部计数器`_count`的值。
      >
      > 我们可以利用构造函数，封装私有变量：
      >
      > ```js
      > function StringBuilder() {
      >     var buffer = [];
      > 
      >     this.add = function (str) {
      >     	buffer.push(str);
      >     };
      > 
      >     this.toString = function () {
      >     	return buffer.join('');
      >     };
      > }
      > ```
      >
      > 上面代码中，`buffer`是函数里的局部变量，一旦生成实例对象，外部是无法直接访问`buffer`的。
      >
      > 但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。
      >
      > 另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。
      >
      > ```js
      > var module1 = (function () {
      >     var _count = 0;
      >     var m1 = function () {
      > 	    //...
      >     };
      >     var m2 = function () {
      >     	//...
      >     };
      >     return {
      >         m1 : m1,
      >         m2 : m2
      >     };
      > })();
      > ```
      >
      > 下面再对这种写法进行加工。
      >
      > 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。
      >
      > ```js
      > var module1 = (function (mod){
      >     mod.m3 = function () {
      >     	//...
      >     };
      >     return mod;
      > })(module1);
      > ```
      >
      > 上面的代码为`module1`模块添加了一个新方法`m3()`，然后返回新的`module1`模块。
      >
      > 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用"宽放大模式"（Loose augmentation）。
      >
      > ```js
      > var module1 = (function (mod) {
      > 　//...
      > 　return mod;
      > })(window.module1 || {});
      > ```
      >
      > 与"放大模式"相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。

      > 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。
      >
      > 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。
      >
      > ```js
      > var module1 = (function ($, YAHOO) {
      > 　//...
      > })(jQuery, YAHOO);
      > ```
      >
      > 上面的`module1`模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入`module1`。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。
      >
      > 立即执行函数还可以起到命名空间的作用。
      >
      > ```js
      > (function($, window, document) {
      > 
      >   function go(num) {
      >   }
      > 
      >   function handleEvents() {
      >   }
      > 
      >   function initialize() {
      >   }
      > 
      >   function dieCarouselDie() {
      >   }
      > 
      >   //attach to the global scope
      >   window.finalCarousel = {
      >     init : initialize,
      >     destroy : dieCarouselDie
      >   }
      > 
      > })( jQuery, window, document );
      > ```
      >
      > 上面代码中，`finalCarousel`对象输出到全局，对外暴露`init`和`destroy`接口，内部方法`go`、`handleEvents`、`initialize`、`dieCarouselDie`都是外部无法调用的。

  - ### 严格模式

    > 除了正常的运行模式，JS 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 JS 语法。
    >
    > 同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行。

    ##### 设计目的：

    > 早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。
    >
    > 严格模式是从 ES5 进入标准的，主要目的有以下几个：
    >
    > - 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。
    > - 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。
    > - 提高编译器效率，提升运行速度。
    > - 为未来新版本的 JavaScript 语法做好铺垫。
    >
    > 总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。

    ##### 开启严格模式：

    > 进入严格模式的标志，是一行字符串`'use strict';`。
    >
    > 老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。

    ##### 严格模式可以用于整个脚本，也可以只用于单个函数：

    - **整个脚本文件：**`use strict`放在脚本文件的第一行，**整个脚本**都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。（严格地说，只要前面不是产生实际运行结果的语句，`use strict`可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面）
    - **单个函数：**`use strict`放在函数体的第一行，则整个函数以严格模式运行。

    > 有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。
    >
    > ```js
    > (function () {
    >     'use strict';
    >     // some code here
    > })();
    > ```

    ##### 严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错：

    > 1. 严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。
    >
    > 2. 严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。
    >
    > 3. 严格模式下，对禁止扩展的对象添加新属性，会报错。
    >
    > 4. 严格模式下，函数只能在全局作用域、函数作用域中声明。
    >
    > 5. 严格模式下，使用`eval`或者`arguments`作为标识符，将会报错。
    >
    > 6. 正常模式下，如果函数有多个重名的参数，可以用`arguments[i]`读取。严格模式下，这属于语法错误。
    >
    > 7. 正常模式下，整数的第一位如果是`0`，表示这是八进制数，比如`0100`等于十进制的64。严格模式禁止这种表示法，整数第一位为`0`，将报错。
    >
    > 8. 正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量必须先声明再使用。
    >
    > 9. 正常模式下，函数内部的`this`可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。此时this是`undefined`。
    >
    >    > 这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加`new`，这时`this`不再指向全局对象，而是报错。
    >    >
    >    > ```js
    >    > function f() {
    >    >     'use strict';
    >    >     this.a = 1;
    >    > };
    >    > f();  // 报错，this 未定义
    >    > ```
    >
    > 10. 严格模式下，函数直接调用时（不使用`new`调用），函数内部的`this`表示`undefined`（未定义），因此可以用`call`、`apply`和`bind`方法，将任意值绑定在`this`上面。正常模式下，`this`指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而`null`和`undefined`这两个无法转成对象的值，将被忽略。
    >
    >    ```js
    >    // 正常模式
    >    function fun() {
    >      return this;
    >    }
    >    
    >    fun() // window
    >    fun.call(2) // Number {2}
    >    fun.call(true) // Boolean {true}
    >    fun.call(null) // window
    >    fun.call(undefined) // window
    >    
    >    // 严格模式
    >    'use strict';
    >    function fun() {
    >      return this;
    >    }
    >    
    >    fun() //undefined
    >    fun.call(2) // 2
    >    fun.call(true) // true
    >    fun.call(null) // null
    >    fun.call(undefined) // undefined
    >    ```
    >
    >    上面代码中，可以把任意类型的值，绑定在`this`上面。
    >
    > 11. 严格模式下禁止使用`with`语句。
    >
    > 12. 严格模式下禁止删除属性，会报错。除非对象的属性的描述对象的`configurable`设置为`true`。
    >
    > 13. 严格模式下，函数内部改变参数与`arguments`的联系被切断了，两者不再存在联动关系。
    >
    > 14. 严格模式创设了第三种作用域：`eval`作用域。也就是说，`eval`所生成的变量只能用于`eval`内部。
    >
    > 严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。

    ##### 向下一个版本的 JavaScript 过渡：
    
    > JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。
    >
    > 1. ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。
    > 2. 为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。