## 操作历史

- #### 简介

  Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录，默认是保存最近的500条命令。有了操作历史以后，就可以使用方向键的`↑`和`↓`，快速浏览上一条和下一条命令。

  退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入`~/.bash_history`文件，该文件默认储存500个操作。

  环境变量`HISTFILE`总是指向这个文件。

  ```bash
  $ echo $HISTFILE
  /home/me/.bash_history
  ```

- #### history 命令

  `history`命令会输出`.bash_history`文件的全部内容，即输出操作历史。

  ```
  $ history
  ...
  498 echo Goodbye
  499 ls ~
  500 cd
  ```

  用户可以使用这个命令，查看最近的操作。相比直接读取`.bash_history`文件，它的优势在于所有命令之前加上了行号。最近的操作在最后面，行号最大。

  如果想搜索某个以前执行的命令，可以配合`grep`命令搜索操作历史。

  ```
  $ history | grep /usr/bin
  ```

  上面命令返回`.bash_history`文件里面，那些包含`/usr/bin`的命令。

  `history`命令的`-c`参数可以清除操作历史，即清空`.bash_history`文件。

  ```bash
  $ history -c
  ```

- #### 环境变量

  - ##### `HISTTIMEFORMAT`

    通过定制环境变量`HISTTIMEFORMAT`，`history`的输出结果还可以显示每个操作的时间。

    ```
    $ export HISTTIMEFORMAT='%F %T  '
    $ history
    1  2013-06-09 10:40:12   cat /etc/issue
    2  2013-06-09 10:40:12   clear
    ```

    上面代码中，`%F`相当于`%Y - %m - %d`（年-月-日），`%T`相当于`%H : %M : %S`（时:分:秒）。

    只要设置`HISTTIMEFORMAT`这个环境变量，就会在`.bash_history`文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。

  - ##### `HISTSIZE`

    环境变量`HISTSIZE`设置保存历史操作的数量。

    ```
    $ export HISTSIZE=10000
    ```

    上面命令设置保存过去10000条操作历史。

    如果不希望保存本次操作的历史，可以设置`HISTSIZE`等于0。

    ```
    export HISTSIZE=0
    ```

    如果`HISTSIZE=0`写入用户主目录的`~/.bashrc`文件，那么就不会保留该用户的操作历史。如果写入`/etc/profile`，整个系统都不会保留操作历史。

  - ##### `HISTIGNORE`

    环境变量`HISTIGNORE`可以设置哪些命令不写入操作历史。

    ```
    export HISTIGNORE='pwd:ls:exit'
    ```

    上面示例设置，`pwd`、`ls`、`exit`这三个命令不写入操作历史。

- #### Ctrl + r

  > 输入命令时，按下`Ctrl + r`快捷键，就可以搜索操作历史，选择以前执行过的命令。
  >
  > `Ctrl + r`相当于打开一个`.bash_history`文件的搜索接口，直接键入命令的开头部分，Shell 就会自动在该文件中反向查询（即先查询最近的命令），显示最近一条匹配的结果，这时按下回车键，就会执行那条命令。

- #### ! 命令

  - ##### `!行号`

    操作历史的每一条记录都有行号。知道了命令的行号以后，可以用`感叹号 + 行号`执行该命令。如果想要执行`.bash_history`里面的第8条命令，可以像下面这样操作。

    ```bash
    $ !8
    ```

  - ##### `!-数字`

    如果想执行本次 Shell 对话中倒数的命令，比如执行倒数第3条命令，就可以输入`!-3`。

    ```
    $ touch a.txt
    $ touch b.txt
    $ touch c.txt
    
    $ !-3
    touch a.txt
    ```

    上面示例中，`!-3`返回倒数第3条命令，即`touch a.txt`。

    它跟`! + 行号`的主要区别是，后者是在`.bash_history`文件中从头开始计算行数，而`!- 数字`是从底部开始向上计算行数。

  - ##### `!!`

    `!!`命令返回上一条命令。如果需要重复执行某一条命令，就可以不断键入`!!`，这样非常方便。它等同于`!-1`。

    ```
    $ echo hello
    hello
    
    $ !!
    echo hello
    hello
    ```

    上面示例中，`!!`会返回并执行上一条命令`echo hello`。

    有时候，我们使用某条命令，系统报错没有权限，这时就可以使用`sudo !!`。

    ```
    # 报错，没有执行权限
    $ yum update
    
    $ sudo !!
    sudo yum update
    ```

    上面示例中，`sudo !!`返回`sudo yum update`，从而就可以正确执行了。

  - ##### `!搜索词`

    `感叹号 + 搜索词`可以快速执行匹配的命令。

    ```
    $ echo Hello World
    Hello World
    
    $ echo Goodbye
    Goodbye
    
    $ !e
    echo Goodbye
    Goodbye
    ```

    上面例子中，`!e`表示找出操作历史之中，最近的那一条以`e`开头的命令并执行。Bash 会先输出那一条命令`echo Goodbye`，然后直接执行。

    同理，`!echo`也会执行最近一条以`echo`开头的命令。

    ```
    $ !echo
    echo Goodbye
    Goodbye
    
    $ !echo H
    echo Goodbye H
    Goodbye H
    
    $ !echo H G
    echo Goodbye H G
    Goodbye H G
    ```

    注意，`感叹号 + 搜索词`语法只会匹配命令，不会匹配参数。所以`!echo H`不会执行`echo Hello World`，而是会执行`echo Goodbye`，并把参数`H`附加在这条命令之后。同理，`!echo H G`也是等同于`echo Goodbye`命令之后附加`H G`。

    由于`感叹号 + 搜索词`会扩展成以前执行过的命令，所以含有`!`的字符串放在双引号里面，必须非常小心，如果它后面有非空格的字符，就很有可能报错。

    ```
    $ echo "I say:\"hello!\""
    bash: !\: event not found
    ```

    上面的命令会报错，原因是感叹号后面是一个反斜杠，Bash 会尝试寻找，以前是否执行过反斜杠开头的命令，一旦找不到就会报错。解决方法就是在感叹号前面，也加上反斜杠。

    ```bash
    $ echo "I say:\"hello\!\""
    I say:"hello\!"
    ```

  - ##### `!?搜索词`

    `!? + 搜索词`可以搜索命令的任意部分，包括参数部分。它跟`! + 搜索词`的主要区别是，后者是从行首开始匹配。

    ```
    $ cat hello.txt
    Hello world ..!
    
    $ !?hello.txt
    cat hello.txt
    Hello world ..!
    ```

    上面示例中，`!?hello.txt`会返回最近一条包括`hello.txt`的命令。

  - ##### `!$，!*`

    `!$`代表上一个命令的最后一个参数，它的另一种写法是`$_`。

    `!*`代表上一个命令的所有参数，即除了命令以外的所有部分。

    ```
    $ cp a.txt b.txt
    $ echo !$
    b.txt
    
    $ cp a.txt b.txt
    $ echo !*
    a.txt b.txt
    ```

    上面示例中，`!$`代表上一个命令的最后一个参数（`b.txt`），`!*`代表上一个命令的所有参数（`a.txt b.txt`）。

    如果想匹配上一个命令的某个指定位置的参数，使用`!:n`。

    ```
    $ ls a.txt b.txt c.txt
    
    $ echo !:2
    b.txt
    ```

    上面示例中，`!:2`返回上一条命令的第二个参数（`b.txt`）。

    这种写法的`!:$`，代表上一个命令的最后一个参数。事实上，`!$`就是`!:$`的简写形式。

    ```
    $ ls a.txt b.txt c.txt
    
    $ echo !:$
    echo c.txt
    c.txt
    ```

    上面示例中，`!:$`代表上一条命令的最后一个参数（`c.txt`）。

    如果想匹配更久以前的命令的参数，可以使用`!<命令>:n`（指定位置的参数）和`!<命令>:$`（最后一个参数）。

    ```
    $ ls !mkdir:$
    ```

    上面示例中，`!mkdir:$`会返回前面最后一条`mkdir`命令的最后一个参数。

    ```
    $ ls !mk:2
    ```

    上面示例中，`!mk:2`会返回前面最后一条以`mk`开头的命令的第二个参数。

  - ##### `!:p`

    如果只是想输出上一条命令，而不是执行它，可以使用`!:p`。

    ```
    $ echo hello
    
    $ !:p
    echo hello
    ```

    上面示例中，`!:p`只会输出`echo hello`，而不会执行这条命令。

    如果想输出最近一条匹配的命令，而不执行它，可以使用`!<命令>:p`。

    ```
    $ !su:p
    ```

    上面示例中，`!su:p`会输出前面最近一条以`su`开头的命令，而不执行它。

- #### `^string1^string2`

  `^string1^string2`用来执行最近一条包含`string1`的命令，将其替换成`string2`。

  ```bash
  $ rm /var/log/httpd/error.log
  $ ^error^access
  rm /var/log/httpd/access.log
  ```

  上面示例中，`^error^access`将最近一条含有`error`的命令里面的`error`，替换成`access`。

- #### `histverify` 参数

  > 上面的那些快捷命令（比如`!!`命令），都是找到匹配的命令后，直接执行。如果希望增加一个确认步骤，先输出是什么命令，让用户确认后再执行，可以打开 Shell 的`histverify`选项。
  >
  > ```bash
  > $ shopt -s histverify
  > ```
  >
  > 打开`histverify`这个选项后，使用`!`快捷键所返回的命令，就会先输出，等到用户按下回车键后再执行。

- #### 快捷键

  下面是其他一些与操作历史相关的快捷键。

  - `Ctrl + p`：显示上一个命令，与向上箭头效果相同（previous）。
  - `Ctrl + n`：显示下一个命令，与向下箭头效果相同（next）。
  - `Alt + <`：显示第一个命令。
  - `Alt + >`：显示最后一个命令，即当前的命令。
  - `Ctrl + o`：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。

## 行操作

- #### 简介

  > Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。
  >
  > 这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。
  >
  > ```
  > $ set -o vi
  > ```
  >
  > 下面的命令可以改回 Emacs 快捷键。
  >
  > ```
  > $ set -o emacs
  > ```
  >
  > 如果想永久性更改编辑模式（Emacs / Vi），可以将命令写在`~/.inputrc`文件，这个文件是 Readline 的配置文件。
  >
  > ```
  > set editing-mode vi
  > ```
  >
  > 本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。
  >
  > Bash 默认开启这个库，但是允许关闭。
  >
  > ```
  > $ bash --noediting
  > ```
  >
  > 上面命令中，`--noediting`参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。

- #### 光标移动

  > Readline 提供快速移动光标的快捷键。
  >
  > - `Ctrl + a`：移到行首。
  > - `Ctrl + b`：向行首移动一个字符，与左箭头作用相同。
  > - `Ctrl + e`：移到行尾。
  > - `Ctrl + f`：向行尾移动一个字符，与右箭头作用相同。
  > - `Alt + f`：移动到当前单词的词尾。
  > - `Alt + b`：移动到当前单词的词首。
  >
  > 上面快捷键的 Alt 键，也可以用 ESC 键代替。

- #### 清除屏幕

  > `Ctrl + l`快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与`clear`命令作用相同。

- #### 编辑操作

  > 下面的快捷键可以编辑命令行内容。
  >
  > - `Ctrl + d`：删除光标位置的字符（delete）。
  > - `Ctrl + w`：删除光标前面的单词。
  > - `Ctrl + t`：光标位置的字符与它前面一位的字符交换位置（transpose）。
  > - `Alt + t`：光标位置的词与它前面一位的词交换位置（transpose）。
  > - `Alt + l`：将光标位置至词尾转为小写（lowercase）。
  > - `Alt + u`：将光标位置至词尾转为大写（uppercase）。
  >
  > 使用`Ctrl + d`的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。
  >
  > 剪切和粘贴快捷键如下。
  >
  > - `Ctrl + k`：剪切光标位置到行尾的文本。
  > - `Ctrl + u`：剪切光标位置到行首的文本。
  > - `Alt + d`：剪切光标位置到词尾的文本。
  > - `Alt + Backspace`：剪切光标位置到词首的文本。
  > - `Ctrl + y`：在光标位置粘贴文本。
  >
  > 同样地，Alt 键可以用 Esc 键代替。

- #### 自动补全

  > 命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入`cle`，再按下 Tab 键，Bash 会自动将这个命令补全为`clear`。
  >
  > 如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。
  >
  > 除了命令或路径，Tab 还可以补全其他值。如果一个值以`$`开头，则按下 Tab 键会补全变量；如果以`~`开头，则补全用户名；如果以`@`开头，则补全主机名（hostname），主机名以列在`/etc/hosts`文件里面的主机为准。
  >
  > 自动补全相关的快捷键如下。
  >
  > - Tab：完成自动补全。
  > - `Alt + ?`：列出可能的补全，与连按两次 Tab 键作用相同。
  > - `Alt + /`：尝试文件路径补全。
  > - `Ctrl + x /`：先按`Ctrl + x`，再按`/`，等同于`Alt + ?`，列出可能的文件路径补全。
  > - `Alt + !`：命令补全。
  > - `Ctrl + x !`：先按`Ctrl + x`，再按`!`，等同于`Alt + !`，命令补全。
  > - `Alt + ~`：用户名补全。
  > - `Ctrl + x ~`：先按`Ctrl + x`，再按`~`，等同于`Alt + ~`，用户名补全。
  > - `Alt + $`：变量名补全。
  > - `Ctrl + x $`：先按`Ctrl + x`，再按`$`，等同于`Alt + $`，变量名补全。
  > - `Alt + @`：主机名补全。
  > - `Ctrl + x @`：先按`Ctrl + x`，再按`@`，等同于`Alt + @`，主机名补全。
  > - `Alt + *`：在命令行一次性插入所有可能的补全。
  > - `Alt + Tab`：尝试用`.bash_history`里面以前执行命令，进行补全。
  >
  > 上面的`Alt`键也可以用 ESC 键代替。

- #### 其他快捷键

  > - `Ctrl + j`：等同于回车键（LINEFEED）。
  > - `Ctrl + m`：等同于回车键（CARRIAGE RETURN）。
  > - `Ctrl + o`：等同于回车键，并展示操作历史的下一个命令。
  > - `Ctrl + v`：将下一个输入的特殊字符变成字面量，比如回车变成`^M`。
  > - `Ctrl + [`：等同于 ESC。
  > - `Alt + .`：插入上一个命令的最后一个词。
  > - `Alt + _`：等同于`Alt + .`。
  >
  > 上面的`Alt + .`快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。
  >
  > ```
  > $ mkdir foo_bar
  > $ cd #按下 Alt + .
  > ```
  >
  > 上面例子中，在`cd`命令后按下`Alt + .`，就会自动插入`foo_bar`。

## 目录堆栈

> 为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。

- #### `cd -`

  > Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，`cd -`命令可以返回前一次的目录。
  >
  > ```
  > # 当前目录是 /path/to/foo
  > $ cd bar
  > 
  > # 重新回到 /path/to/foo
  > $ cd -
  > ```
  >
  > 上面例子中，用户原来所在的目录是`/path/to/foo`，进入子目录`bar`以后，使用`cd -`可以回到原来的目录。

- #### `pushd`，`popd`

  > 如果希望记忆多重目录，可以使用`pushd`命令和`popd`命令。它们用来操作目录堆栈。
  >
  > `pushd`命令的用法类似`cd`命令，可以进入指定的目录。
  >
  > ```
  > $ pushd dirname
  > ```
  >
  > 上面命令会进入目录`dirname`，并将该目录放入堆栈。
  >
  > 第一次使用`pushd`命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用`pushd`命令，都会将所要进入的目录，放在堆栈的顶部。
  >
  > `popd`命令不带有参数时，会移除堆栈的顶部记录，并进入新的栈顶目录（即原来的第二条目录）。
  >
  > 下面是一个例子。
  >
  > ```
  > # 当前处在主目录，堆栈为空
  > $ pwd
  > /home/me
  > 
  > # 进入 /home/me/foo
  > # 当前堆栈为 /home/me/foo /home/me
  > $ pushd ~/foo
  > 
  > # 进入 /etc
  > # 当前堆栈为 /etc /home/me/foo /home/me
  > $ pushd /etc
  > 
  > # 进入 /home/me/foo
  > # 当前堆栈为 /home/me/foo /home/me
  > $ popd
  > 
  > # 进入 /home/me
  > # 当前堆栈为 /home/me
  > $ popd
  > 
  > # 目录不变，当前堆栈为空
  > $ popd
  > ```
  >
  > 这两个命令的参数如下。
  >
  > **（1）-n 参数**
  >
  > `-n`的参数表示仅操作堆栈，不改变目录。
  >
  > ```
  > $ popd -n
  > ```
  >
  > 上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。
  >
  > **（2）整数参数**
  >
  > 这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录（从0开始）。`pushd`命令会把这条记录移动到栈顶，同时切换到该目录；`popd`则从堆栈中删除这条记录，不会切换目录。
  >
  > ```
  > # 将从栈顶算起的3号目录（从0开始）移动到栈顶，同时切换到该目录
  > $ pushd +3
  > 
  > # 将从栈底算起的3号目录（从0开始）移动到栈顶，同时切换到该目录
  > $ pushd -3
  > 
  > # 删除从栈顶算起的3号目录（从0开始），不改变当前目录
  > $ popd +3
  > 
  > # 删除从栈底算起的3号目录（从0开始），不改变当前目录
  > $ popd -3
  > ```
  >
  > 上面例子的整数编号都是从0开始计算，`popd +0`是删除第一个目录，`popd +1`是删除第二个，`popd -0`是删除最后一个目录，`popd -1`是删除倒数第二个。
  >
  > **（3）目录参数**
  >
  > `pushd`可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。
  >
  > ```
  > $ pushd dir
  > ```
  >
  > `popd`没有这个参数。

- #### `dirs` 命令

  > `dirs`命令可以显示目录堆栈的内容，一般用来查看`pushd`和`popd`操作后的结果。
  >
  > ```
  > $ dirs
  > ~/foo/bar ~/foo ~
  > ```
  >
  > 该命令会输出一行文本，列出目录堆栈，目录之间使用空格分隔。栈顶（最晚入栈的目录）在最左边，栈底（最早入栈的目录）在最右边。
  >
  > 它有以下参数。
  >
  > - `-c`：清空目录栈。
  > - `-l`：用户主目录不显示波浪号前缀，而打印完整的目录。
  > - `-p`：每行一个条目打印目录栈，默认是打印在一行。
  > - `-v`：每行一个条目，每个条目之前显示位置编号（从0开始）。
  > - `+N`：`N`为整数，表示显示堆顶算起的第 N 个目录，从零开始。
  > - `-N`：`N`为整数，表示显示堆底算起的第 N 个目录，从零开始。

## Bash 脚本入门

> 脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。
>
> 脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。

- #### `Shebang` 行

  > 脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以`#!`字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。
  >
  > `#!`后面就是脚本解释器的位置，Bash 脚本的解释器一般是`/bin/sh`或`/bin/bash`。
  >
  > ```
  > #!/bin/sh
  > # 或者
  > #!/bin/bash
  > ```
  >
  > `#!`与脚本解释器之间有没有空格，都是可以的。
  >
  > 如果 Bash 解释器不放在目录`/bin`，脚本就无法执行了。为了保险，可以写成下面这样。
  >
  > ```
  > #!/usr/bin/env bash
  > ```
  >
  > 上面命令使用`env`命令（这个命令总是在`/usr/bin`目录），返回 Bash 可执行文件的位置。`env`命令的详细介绍，请看后文。
  >
  > Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是`script.sh`，有 Shebang 行的时候，可以直接调用执行。
  >
  > ```
  > $ ./script.sh
  > ```
  >
  > 上面例子中，`script.sh`是脚本文件名。脚本通常使用`.sh`后缀名，不过这不是必需的。
  >
  > 如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。
  >
  > ```bash
  > $ /bin/sh ./script.sh
  > # 或者
  > $ bash ./script.sh
  > ```

- #### 执行权限和路径

  > 前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。
  >
  > ```
  > # 给所有用户执行权限
  > $ chmod +x script.sh
  > 
  > # 给所有用户读权限和执行权限
  > $ chmod +rx script.sh
  > # 或者
  > $ chmod 755 script.sh
  > 
  > # 只给脚本拥有者读权限和执行权限
  > $ chmod u+rx script.sh
  > ```
  >
  > 脚本的权限通常设为`755`（拥有者有所有权限，其他人有读和执行权限）或者`700`（只有拥有者可以执行）。
  >
  > 除了执行权限，脚本调用时，一般需要指定脚本的路径（比如`path/script.sh`）。如果将脚本放在环境变量`$PATH`指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。
  >
  > 建议在主目录新建一个`~/bin`子目录，专门存放可执行脚本，然后把`~/bin`加入`$PATH`。
  >
  > ```
  > export PATH=$PATH:~/bin
  > ```
  >
  > 上面命令改变环境变量`$PATH`，将`~/bin`添加到`$PATH`的末尾。可以将这一行加到`~/.bashrc`文件里面，然后重新加载一次`.bashrc`，这个配置就可以生效了。
  >
  > ```
  > $ source ~/.bashrc
  > ```
  >
  > 以后不管在什么目录，直接输入脚本文件名，脚本就会执行。
  >
  > ```
  > $ script.sh
  > ```
  >
  > 上面命令没有指定脚本路径，因为`script.sh`在`$PATH`指定的目录中。

- #### `env` 命令

  > `env`命令总是指向`/usr/bin/env`文件，或者说，这个二进制文件总是在目录`/usr/bin`。
  >
  > `#!/usr/bin/env NAME`这个语法的意思是，让 Shell 查找`$PATH`环境变量里面第一个匹配的`NAME`。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。
  >
  > `/usr/bin/env bash`的意思就是，返回`bash`可执行文件的位置，前提是`bash`的路径是在`$PATH`里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。
  >
  > ```
  > #!/usr/bin/env node
  > ```
  >
  > `env`命令的参数如下。
  >
  > - `-i`, `--ignore-environment`：不带环境变量启动。
  > - `-u`, `--unset=NAME`：从环境变量中删除一个变量。
  > - `--help`：显示帮助。
  > - `--version`：输出版本信息。
  >
  > 下面是一个例子，新建一个不带任何环境变量的 Shell。
  >
  > ```bash
  > $ env -i /bin/sh
  > ```

- #### 注释

  > Bash 脚本中，`#`表示注释，可以放在行首，也可以放在行尾。
  >
  > ```
  > # 本行是注释
  > echo 'Hello World!'
  > 
  > echo 'Hello World!' # 井号后面的部分也是注释
  > ```
  >
  > 建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。

- #### 脚本参数

  > 调用脚本的时候，脚本文件名后面可以带有参数。
  >
  > ```
  > $ script.sh word1 word2 word3
  > ```
  >
  > 上面例子中，`script.sh`是一个脚本文件，`word1`、`word2`和`word3`是三个参数。
  >
  > 脚本文件内部，可以使用特殊变量，引用这些参数。
  >
  > - `$0`：脚本文件名，即`script.sh`。
  > - `$1`~`$9`：对应脚本的第一个参数到第九个参数。
  > - `$#`：参数的总数。
  > - `$@`：全部的参数，参数之间使用空格分隔。
  > - `$*`：全部的参数，参数之间使用变量`$IFS`值的第一个字符分隔，默认为空格，但是可以自定义。
  >
  > 如果脚本的参数多于9个，那么第10个参数可以用`${10}`的形式引用，以此类推。
  >
  > 注意，如果命令是`command -o foo bar`，那么`-o`是`$1`，`foo`是`$2`，`bar`是`$3`。
  >
  > 下面是一个脚本内部读取命令行参数的例子。
  >
  > ```
  > #!/bin/bash
  > # script.sh
  > 
  > echo "全部参数：" $@
  > echo "命令行参数数量：" $#
  > echo '$0 = ' $0
  > echo '$1 = ' $1
  > echo '$2 = ' $2
  > echo '$3 = ' $3
  > ```
  >
  > 执行结果如下。
  >
  > ```
  > $ ./script.sh a b c
  > 全部参数：a b c
  > 命令行参数数量：3
  > $0 =  script.sh
  > $1 =  a
  > $2 =  b
  > $3 =  c
  > ```
  >
  > 用户可以输入任意数量的参数，利用`for`循环，可以读取每一个参数。
  >
  > ```
  > #!/bin/bash
  > 
  > for i in "$@"; do
  >   echo $i
  > done
  > ```
  >
  > 上面例子中，`$@`返回一个全部参数的列表，然后使用`for`循环遍历。
  >
  > 如果多个参数放在双引号里面，视为一个参数。
  >
  > ```
  > $ ./script.sh "a b"
  > ```
  >
  > 上面例子中，Bash 会认为`"a b"`是一个参数，`$1`会返回`a b`。注意，返回时不包括双引号。

- #### `shift` 命令

  > `shift`命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数（`$1`），使得后面的参数向前一位，即`$2`变成`$1`、`$3`变成`$2`、`$4`变成`$3`，以此类推。
  >
  > `while`循环结合`shift`命令，也可以读取每一个参数。
  >
  > ```
  > #!/bin/bash
  > 
  > echo "一共输入了 $# 个参数"
  > 
  > while [ "$1" != "" ]; do
  >   echo "剩下 $# 个参数"
  >   echo "参数：$1"
  >   shift
  > done
  > ```
  >
  > 上面例子中，`shift`命令每次移除当前第一个参数，从而通过`while`循环遍历所有参数。
  >
  > `shift`命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为`1`。
  >
  > ```
  > shift 3
  > ```
  >
  > 上面的命令移除前三个参数，原来的`$4`变成`$1`。

- #### `getopts` 命令

  > `getopts`命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与`while`循环一起使用，取出脚本所有的带有前置连词线（`-`）的参数。
  >
  > ```
  > getopts optstring name
  > ```
  >
  > 它带有两个参数。第一个参数`optstring`是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数`-l`、`-h`、`-a`，其中只有`-a`可以带有参数值，而`-l`和`-h`是开关参数，那么`getopts`的第一个参数写成`lha:`，顺序不重要。注意，`a`后面有一个冒号，表示该参数带有参数值，`getopts`规定带有参数值的配置项参数，后面必须带有一个冒号（`:`）。`getopts`的第二个参数`name`是一个变量名，用来保存当前取到的配置项参数，即`l`、`h`或`a`。
  >
  > 下面是一个例子。
  >
  > ```
  > while getopts 'lha:' OPTION; do
  >   case "$OPTION" in
  >     l)
  >       echo "linuxconfig"
  >       ;;
  > 
  >     h)
  >       echo "h stands for h"
  >       ;;
  > 
  >     a)
  >       avalue="$OPTARG"
  >       echo "The value provided is $OPTARG"
  >       ;;
  >     ?)
  >       echo "script usage: $(basename $0) [-l] [-h] [-a somevalue]" >&2
  >       exit 1
  >       ;;
  >   esac
  > done
  > shift "$(($OPTIND - 1))"
  > ```
  >
  > 上面例子中，`while`循环不断执行`getopts 'lha:' OPTION`命令，每次执行就会读取一个连词线参数（以及对应的参数值），然后进入循环体。变量`OPTION`保存的是，当前处理的那一个连词线参数（即`l`、`h`或`a`）。如果用户输入了没有指定的参数（比如`-x`），那么`OPTION`等于`?`。循环体内使用`case`判断，处理这四种不同的情况。
  >
  > 如果某个连词线参数带有参数值，比如`-a foo`，那么处理`a`参数的时候，环境变量`$OPTARG`保存的就是参数值。
  >
  > 注意，只要遇到不带连词线的参数，`getopts`就会执行失败，从而退出`while`循环。比如，`getopts`可以解析`command -l foo`，但不可以解析`command foo -l`。另外，多个连词线参数写在一起的形式，比如`command -lh`，`getopts`也可以正确处理。
  >
  > 变量`$OPTIND`在`getopts`开始执行前是`1`，然后每次执行就会加`1`。等到退出`while`循环，就意味着连词线参数全部处理完毕。这时，`$OPTIND - 1`就是已经处理的连词线参数个数，使用`shift`命令将这些参数移除，保证后面的代码可以用`$1`、`$2`等处理命令的主参数。

- #### 配置项参数终止符 `--`

  > `-`和`--`开头的参数，会被 Bash 当作配置项解释。但是，有时它们不是配置项，而是实体参数的一部分，比如文件名叫做`-f`或`--file`。
  >
  > ```
  > $ cat -f
  > $ cat --file
  > ```
  >
  > 上面命令的原意是输出文件`-f`和`--file`的内容，但是会被 Bash 当作配置项解释。
  >
  > 这时就可以使用配置项参数终止符`--`，它的作用是告诉 Bash，在它后面的参数开头的`-`和`--`不是配置项，只能当作实体参数解释。
  >
  > ```
  > $ cat -- -f
  > $ cat -- --file
  > ```
  >
  > 上面命令可以正确展示文件`-f`和`--file`的内容，因为它们放在`--`的后面，开头的`-`和`--`就不再当作配置项解释了。
  >
  > 如果要确保某个变量不会被当作配置项解释，就要在它前面放上参数终止符`--`。
  >
  > ```
  > $ ls -- $myPath
  > ```
  >
  > 上面示例中，`--`强制变量`$myPath`只能当作实体参数（即路径名）解释。如果变量不是路径名，就会报错。
  >
  > ```
  > $ myPath="-l"
  > $ ls -- $myPath
  > ls: 无法访问'-l': 没有那个文件或目录
  > ```
  >
  > 上面例子中，变量`myPath`的值为`-l`，不是路径。但是，`--`强制`$myPath`只能作为路径解释，导致报错“不存在该路径”。
  >
  > 下面是另一个实际的例子，如果想在文件里面搜索`--hello`，这时也要使用参数终止符`--`。
  >
  > ```
  > $ grep -- "--hello" example.txt
  > ```
  >
  > 上面命令在`example.txt`文件里面，搜索字符串`--hello`。这个字符串是`--`开头，如果不用参数终止符，`grep`命令就会把`--hello`当作配置项参数，从而报错。

- #### `exit` 命令

  > `exit`命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。
  >
  > ```
  > $ exit
  > ```
  >
  > 上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。
  >
  > `exit`命令后面可以跟参数，该参数就是退出状态。
  >
  > ```
  > # 退出值为0（成功）
  > $ exit 0
  > 
  > # 退出值为1（失败）
  > $ exit 1
  > ```
  >
  > 退出时，脚本会返回一个退出值。脚本的退出值，`0`表示正常，`1`表示发生错误，`2`表示用法不对，`126`表示不是可执行脚本，`127`表示命令没有发现。如果脚本被信号`N`终止，则退出值为`128 + N`。简单来说，只要退出值非0，就认为执行出错。
  >
  > 下面是一个例子。
  >
  > ```
  > if [ $(id -u) != "0" ]; then
  >   echo "根用户才能执行当前脚本"
  >   exit 1
  > fi
  > ```
  >
  > 上面的例子中，`id -u`命令返回用户的 ID，一旦用户的 ID 不等于`0`（根用户的 ID），脚本就会退出，并且退出码为`1`，表示运行失败。
  >
  > `exit`与`return`命令的差别是，`return`命令是函数的退出，并返回一个值给调用者，脚本依然执行。`exit`是整个脚本的退出，如果在函数之中调用`exit`，则退出函数，并终止脚本执行。

- #### 命令执行结果

  > 命令执行结束后，会有一个返回值。`0`表示执行成功，非`0`（通常是`1`）表示执行失败。环境变量`$?`可以读取前一个命令的返回值。
  >
  > 利用这一点，可以在脚本中对命令执行结果进行判断。
  >
  > ```
  > cd /path/to/somewhere
  > if [ "$?" = "0" ]; then
  >   rm *
  > else
  >   echo "无法切换目录！" 1>&2
  >   exit 1
  > fi
  > ```
  >
  > 上面例子中，`cd /path/to/somewhere`这个命令如果执行成功（返回值等于`0`），就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为`1`，表示执行失败。
  >
  > 由于`if`可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。
  >
  > ```
  > if cd /path/to/somewhere; then
  >   rm *
  > else
  >   echo "Could not change directory! Aborting." 1>&2
  >   exit 1
  > fi
  > ```
  >
  > 更简洁的写法是利用两个逻辑运算符`&&`（且）和`||`（或）。
  >
  > ```bash
  > # 第一步执行成功，才会执行第二步
  > cd /path/to/somewhere && rm *
  > 
  > # 第一步执行失败，才会执行第二步
  > cd /path/to/somewhere || exit 1
  > ```

- #### `source` 命令

  > `source`命令用于执行一个脚本，通常用于重新加载一个配置文件。
  >
  > ```
  > $ source .bashrc
  > ```
  >
  > `source`命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，`source`命令执行脚本时，不需要`export`变量。
  >
  > ```
  > #!/bin/bash
  > # test.sh
  > echo $foo
  > ```
  >
  > 上面脚本输出`$foo`变量的值。
  >
  > ```
  > # 当前 Shell 新建一个变量 foo
  > $ foo=1
  > 
  > # 打印输出 1
  > $ source test.sh
  > 1
  > 
  > # 打印输出空字符串
  > $ bash test.sh
  > ```
  >
  > 上面例子中，当前 Shell 的变量`foo`并没有`export`，所以直接执行无法读取，但是`source`执行可以读取。
  >
  > `source`命令的另一个用途，是在脚本内部加载外部库。
  >
  > ```
  > #!/bin/bash
  > 
  > source ./lib.sh
  > 
  > function_from_lib
  > ```
  >
  > 上面脚本在内部使用`source`命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。
  >
  > `source`有一个简写形式，可以使用一个点（`.`）来表示。
  >
  > ```bash
  > $ . .bashrc
  > ```

- #### 别名，`alias` 命令

  > `alias`命令用来为一个命令指定别名，这样更便于记忆。下面是`alias`的格式。
  >
  > ```
  > alias NAME=DEFINITION
  > ```
  >
  > 上面命令中，`NAME`是别名的名称，`DEFINITION`是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。
  >
  > 一个常见的例子是为`grep`命令起一个`search`的别名。
  >
  > ```
  > alias search=grep
  > ```
  >
  > `alias`也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个`today`的命令。
  >
  > ```
  > $ alias today='date +"%A, %B %-d, %Y"'
  > $ today
  > 星期一, 一月 6, 2020
  > ```
  >
  > 有时为了防止误删除文件，可以指定`rm`命令的别名。
  >
  > ```
  > $ alias rm='rm -i'
  > ```
  >
  > 上面命令指定`rm`命令是`rm -i`，每次删除文件之前，都会让用户确认。
  >
  > `alias`定义的别名也可以接受参数，参数会直接传入原始命令。
  >
  > ```
  > $ alias echo='echo It says: '
  > $ echo hello world
  > It says: hello world
  > ```
  >
  > 上面例子中，别名定义了`echo`命令的前两个参数，等同于修改了`echo`命令的默认行为。
  >
  > 指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在`~/.bashrc`的末尾。另外，只能为命令定义别名，为其他部分（比如很长的路径）定义别名是无效的。
  >
  > 直接调用`alias`命令，可以显示所有别名。
  >
  > ```
  > $ alias
  > ```
  >
  > `unalias`命令可以解除别名。
  >
  > ```bash
  > $ unalias lt
  > ```

------

