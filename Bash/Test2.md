- ## 变量

  - #### 简介

    > Bash 变量分成环境变量和自定义变量两类。

    - ##### 环境变量

      环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。

      `env`命令或`printenv`命令，可以显示所有环境变量。

      ```
      $ env
      # 或者
      $ printenv
      ```

      下面是一些常见的环境变量。

      - `BASHPID`：Bash 进程的进程 ID。
      - `BASHOPTS`：当前 Shell 的参数，可以用`shopt`命令修改。
      - `DISPLAY`：图形环境的显示器名字，通常是`:0`，表示 X Server 的第一个显示器。
      - `EDITOR`：默认的文本编辑器。
      - `HOME`：用户的主目录。
      - `HOST`：当前主机的名称。
      - `IFS`：词与词之间的分隔符，默认为空格。
      - `LANG`：字符集以及语言编码，比如`zh_CN.UTF-8`。
      - `PATH`：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。
      - `PS1`：Shell 提示符。
      - `PS2`： 输入多行命令时，次要的 Shell 提示符。
      - `PWD`：当前工作目录。
      - `RANDOM`：返回一个0到32767之间的随机数。
      - `SHELL`：Shell 的名字。
      - `SHELLOPTS`：启动当前 Shell 的`set`命令的参数，参见《set 命令》一章。
      - `TERM`：终端类型名，即终端仿真器所用的协议。
      - `UID`：当前用户的 ID 编号。
      - `USER`：当前用户的用户名。

      很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。

      注意，Bash 变量名区分大小写，`HOME`和`home`是两个不同的变量。

      查看单个环境变量的值，可以使用`printenv`命令或`echo`命令。

      ```
      $ printenv PATH
      # 或者
      $ echo $PATH
      ```

      注意，`printenv`命令后面的变量名，不用加前缀`$`。

    - ##### 自定义变量

      自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。

      `set`命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

      ```bash
      $ set
      ```

  - #### 创建变量

    用户创建变量的时候，变量名必须遵守下面的规则。

    - 字母、数字和下划线字符组成。
    - 第一个字符必须是一个字母或一个下划线，不能是数字。
    - 不允许出现空格和标点符号。

    变量声明的语法如下。

    ```
    variable=value
    ```

    上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。

    如果变量的值包含空格，则必须将值放在引号中。

    ```
    myvar="hello world"
    ```

    Bash 没有数据类型的概念，所有的变量值都是字符串。

    下面是一些自定义变量的例子。

    ```
    a=z                     # 变量 a 赋值为字符串 z
    b="a string"            # 变量值包含空格，就必须放在引号里面
    c="a string and $b"     # 变量值可以引用其他变量的值
    d="\t\ta string\n"      # 变量值可以使用转义字符
    e=$(ls -l foo.txt)      # 变量值可以是命令的执行结果
    f=$((5 * 7))            # 变量值可以是数学运算的结果
    ```

    变量可以重复赋值，后面的赋值会覆盖前面的赋值。

    ```
    $ foo=1
    $ foo=2
    $ echo $foo
    2
    ```

    上面例子中，变量`foo`的第二次赋值会覆盖第一次赋值。

    如果同一行定义多个变量，必须使用分号（`;`）分隔。

    ```
    $ foo=1;bar=2
    ```

    上面例子中，同一行定义了`foo`和`bar`两个变量。

  - #### 读取变量

    读取变量的时候，直接在变量名前加上`$`就可以了。

    ```
    $ foo=bar
    $ echo $foo
    bar
    ```

    每当 Shell 看到以`$`开头的单词时，就会尝试读取这个变量名对应的值。

    如果变量不存在，Bash 不会报错，而会输出空字符。

    由于`$`在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，

    ```
    $ echo The total is $100.00
    The total is 00.00
    ```

    上面命令的原意是输入`$100`，但是 Bash 将`$1`解释成了变量，该变量为空，因此输入就变成了`00.00`。所以，如果要使用`$`的原义，需要在`$`前面放上反斜杠，进行转义。

    ```
    $ echo The total is \$100.00
    The total is $100.00
    ```

    读取变量的时候，变量名也可以使用花括号`{}`包围，比如`$a`也可以写成`${a}`。这种写法可以用于变量名与其他字符连用的情况。

    ```
    $ a=foo
    $ echo $a_file
    
    $ echo ${a}_file
    foo_file
    ```

    上面代码中，变量名`a_file`不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分`$a`，Bash 才能正确解读。

    事实上，读取变量的语法`$foo`，可以看作是`${foo}`的简写形式。

    如果变量的值本身也是变量，可以使用`${!varname}`的语法，读取最终的值。

    ```
    $ myvar=USER
    $ echo ${!myvar}
    ruanyf
    ```

    上面的例子中，变量`myvar`的值是`USER`，`${!myvar}`的写法将其展开成最终的值。

    如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。

    ```
    $ a="1 2  3"
    $ echo $a
    1 2 3
    $ echo "$a"
    1 2  3
    ```

    上面示例中，变量`a`的值包含两个连续空格。如果直接读取，Shell 会将连续空格合并成一个。只有放在双引号里面读取，才能保持原来的格式。

  - #### 删除变量

    `unset`命令用来删除一个变量。

    ```
    unset NAME
    ```

    这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使`unset`命令删除了变量，还是可以读取这个变量，值为空字符串。

    所以，删除一个变量，也可以将这个变量设成空字符串。

    ```
    $ foo=''
    $ foo=
    ```

    上面两种写法，都是删除了变量`foo`。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。

  - #### 输出变量，`export` 命令

    用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用`export`命令。这样输出的变量，对于子 Shell 来说就是环境变量。

    `export`命令用来向子 Shell 输出变量。

    ```
    NAME=foo
    export NAME
    ```

    上面命令输出了变量`NAME`。变量的赋值和输出也可以在一个步骤中完成。

    ```
    export NAME=value
    ```

    上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量`$NAME`。

    子 Shell 如果修改继承的变量，不会影响父 Shell。

    ```
    # 输出变量 $foo
    $ export foo=bar
    
    # 新建子 Shell
    $ bash
    
    # 读取 $foo
    $ echo $foo
    bar
    
    # 修改继承的变量
    $ foo=baz
    
    # 退出子 Shell
    $ exit
    
    # 读取 $foo
    $ echo $foo
    bar
    ```

    上面例子中，子 Shell 修改了继承的变量`$foo`，对父 Shell 没有影响。

  - #### 特殊变量

    Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。

    （1）`$?`

    `$?`为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是`0`，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。

    ```
    $ ls doesnotexist
    ls: doesnotexist: No such file or directory
    
    $ echo $?
    1
    ```

    上面例子中，`ls`命令查看一个不存在的文件，导致报错。`$?`为1，表示上一个命令执行失败。

    （2）`$$`

    `$$`为当前 Shell 的进程 ID。

    ```
    $ echo $$
    10662
    ```

    这个特殊变量可以用来命名临时文件。

    ```
    LOGFILE=/tmp/output_log.$$
    ```

    （3）`$_`

    `$_`为上一个命令的最后一个参数。

    ```
    $ grep dictionary /usr/share/dict/words
    dictionary
    
    $ echo $_
    /usr/share/dict/words
    ```

    （4）`$!`

    `$!`为最近一个后台执行的异步命令的进程 ID。

    ```
    $ firefox &
    [1] 11064
    
    $ echo $!
    11064
    ```

    上面例子中，`firefox`是后台运行的命令，`$!`返回该命令的进程 ID。

    （5）`$0`

    `$0`为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。

    ```
    $ echo $0
    bash
    ```

    上面例子中，`$0`返回当前运行的是 Bash。

    （6）`$-`

    `$-`为当前 Shell 的启动参数。

    ```
    $ echo $-
    himBHs
    ```

    （7）`$@`和`$#`

    `$#`表示脚本的参数数量，`$@`表示脚本的参数值，参见脚本一章。

  - #### 变量的默认值

    Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。

    ```
    ${varname:-word}
    ```

    上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则返回`word`。它的目的是返回一个默认值，比如`${count:-0}`表示变量`count`不存在时返回`0`。

    ```
    ${varname:=word}
    ```

    上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则将它设为`word`，并且返回`word`。它的目的是设置变量的默认值，比如`${count:=0}`表示变量`count`不存在时返回`0`，且将`count`设为`0`。

    ```
    ${varname:+word}
    ```

    上面语法的含义是，如果变量名存在且不为空，则返回`word`，否则返回空值。它的目的是测试变量是否存在，比如`${count:+1}`表示变量`count`存在时返回`1`（表示`true`），否则返回空值。

    ```
    ${varname:?message}
    ```

    上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则打印出`varname: message`，并中断脚本的执行。如果省略了`message`，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如`${count:?"undefined!"}`表示变量`count`未定义时就中断执行，抛出错误，返回给定的报错信息`undefined!`。

    上面四种语法如果用在脚本中，变量名的部分可以用数字`1`到`9`，表示脚本的参数。

    ```
    filename=${1:?"filename missing."}
    ```

    上面代码出现在脚本中，`1`表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。

  - #### `declare` 命令

    `declare`命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。

    它的语法形式如下。

    ```
    declare OPTION VARIABLE=value
    ```

    `declare`命令的主要参数（OPTION）如下。

    - `-a`：声明数组变量。
    - `-f`：输出所有函数定义。
    - `-F`：输出所有函数名。
    - `-i`：声明整数变量。
    - `-l`：声明变量为小写字母。
    - `-p`：查看变量信息。
    - `-r`：声明只读变量。
    - `-u`：声明变量为大写字母。
    - `-x`：该变量输出为环境变量。

    `declare`命令如果用在函数中，声明的变量只在函数内部有效，等同于`local`命令。

    不带任何参数时，`declare`命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的`set`命令。

    ```
    $ declare
    ```

    **（1）`-i`参数**

    `-i`参数声明整数变量以后，可以直接进行数学运算。

    ```
    $ declare -i val1=12 val2=5
    $ declare -i result
    $ result=val1*val2
    $ echo $result
    60
    ```

    上面例子中，如果变量`result`不声明为整数，`val1*val2`会被当作字面量，不会进行整数运算。另外，`val1`和`val2`其实不需要声明为整数，因为只要`result`声明为整数，它的赋值就会自动解释为整数运算。

    注意，一个变量声明为整数以后，依然可以被改写为字符串。

    ```
    $ declare -i var=12
    $ var=foo
    $ echo $var
    0
    ```

    上面例子中，变量`var`声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出0，也可能输出的是3。

    **（2）`-x`参数**

    `-x`参数等同于`export`命令，可以输出一个变量为子 Shell 的环境变量。

    ```
    $ declare -x foo
    # 等同于
    $ export foo
    ```

    **（3）`-r`参数**

    `-r`参数可以声明只读变量，无法改变变量值，也不能`unset`变量。

    ```
    $ declare -r bar=1
    
    $ bar=2
    bash: bar：只读变量
    $ echo $?
    1
    
    $ unset bar
    bash: bar：只读变量
    $ echo $?
    1
    ```

    上面例子中，后两个赋值语句都会报错，命令执行失败。

    **（4）`-u`参数**

    `-u`参数声明变量为大写字母，可以自动把变量值转成大写字母。

    ```
    $ declare -u foo
    $ foo=upper
    $ echo $foo
    UPPER
    ```

    **（5）`-l`参数**

    `-l`参数声明变量为小写字母，可以自动把变量值转成小写字母。

    ```
    $ declare -l bar
    $ bar=LOWER
    $ echo $bar
    lower
    ```

    **（6）`-p`参数**

    `-p`参数输出变量信息。

    ```
    $ foo=hello
    $ declare -p foo
    declare -- foo="hello"
    $ declare -p bar
    bar：未找到
    ```

    上面例子中，`declare -p`可以输出已定义变量的值，对于未定义的变量，会提示找不到。

    如果不提供变量名，`declare -p`输出所有变量的信息。

    ```
    $ declare -p
    ```

    **（7）`-f`参数**

    `-f`参数输出当前环境的所有函数，包括它的定义。

    ```
    $ declare -f
    ```

    **（8）`-F`参数**

    `-F`参数输出当前环境的所有函数名，不包含函数定义。

    ```bash
    $ declare -F
    ```

  - #### `readonly` 命令

    `readonly`命令等同于`declare -r`，用来声明只读变量，不能改变变量值，也不能`unset`变量。

    ```
    $ readonly foo=1
    $ foo=2
    bash: foo：只读变量
    $ echo $?
    1
    ```

    上面例子中，更改只读变量`foo`会报错，命令执行失败。

    `readonly`命令有三个参数。

    - `-f`：声明的变量为函数名。
    - `-p`：打印出所有的只读变量。
    - `-a`：声明的变量为数组。

  - #### `let` 命令

    `let`命令声明变量时，可以直接执行算术表达式。

    ```
    $ let foo=1+2
    $ echo $foo
    3
    ```

    上面例子中，`let`命令可以直接计算`1 + 2`。

    `let`命令的参数表达式如果包含空格，就需要使用引号。

    ```
    $ let "foo = 1 + 2"
    ```

    `let`可以同时对多个变量赋值，赋值表达式之间使用空格分隔。

    ```
    $ let "v1 = 1" "v2 = v1++"
    $ echo $v1,$v2
    2,1
    ```

    上面例子中，`let`声明了两个变量`v1`和`v2`，其中`v2`等于`v1++`，表示先返回`v1`的值，然后`v1`自增。

    这种语法支持的运算符，参考《Bash 的算术运算》一章。

- ## 字符串操作

  > 本章介绍 Bash 字符串操作的语法。

  - #### 字符串的长度

    获取字符串长度的语法如下。

    ```
    ${#varname}
    ```

    下面是一个例子。

    ```
    $ myPath=/home/cam/book/long.file.name
    $ echo ${#myPath}
    29
    ```

    大括号`{}`是必需的，否则 Bash 会将`$#`理解成脚本的参数个数，将变量名理解成文本。

    ```
    $ echo $#myvar
    0myvar
    ```

    上面例子中，Bash 将`$#`和`myvar`分开解释了。

  - #### 子字符串

    字符串提取子串的语法如下。

    ```
    ${varname:offset:length}
    ```

    上面语法的含义是返回变量`$varname`的子字符串，从位置`offset`开始（从`0`开始计算），长度为`length`。

    ```
    $ count=frogfootman
    $ echo ${count:4:4}
    foot
    ```

    上面例子返回字符串`frogfootman`从4号位置开始的长度为4的子字符串`foot`。

    这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。

    ```
    # 报错
    $ echo ${"hello":2:3}
    ```

    上面例子中，`"hello"`不是变量名，导致 Bash 报错。

    如果省略`length`，则从位置`offset`开始，一直返回到字符串的结尾。

    ```
    $ count=frogfootman
    $ echo ${count:4}
    footman
    ```

    上面例子是返回变量`count`从4号位置一直到结尾的子字符串。

    如果`offset`为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与`${variable:-word}`的变量的设置默认值语法混淆。这时还可以指定`length`，`length`可以是正值，也可以是负值（负值不能超过`offset`的长度）。

    ```
    $ foo="This string is long."
    $ echo ${foo: -5}
    long.
    $ echo ${foo: -5:2}
    lo
    $ echo ${foo: -5:-2}
    lon
    ```

    上面例子中，`offset`为`-5`，表示从倒数第5个字符开始截取，所以返回`long.`。如果指定长度`length`为`2`，则返回`lo`；如果`length`为`-2`，表示要排除从字符串末尾开始的2个字符，所以返回`lon`。

  - #### 搜索和替换

    Bash 提供字符串搜索和替换的多种方法。

    **（1）字符串头部的模式匹配。**

    以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。

    ```
    # 如果 pattern 匹配变量 variable 的开头，
    # 删除最短匹配（非贪婪匹配）的部分，返回剩余部分
    ${variable#pattern}
    
    # 如果 pattern 匹配变量 variable 的开头，
    # 删除最长匹配（贪婪匹配）的部分，返回剩余部分
    ${variable##pattern}
    ```

    上面两种语法会删除变量字符串开头的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。

    匹配模式`pattern`可以使用`*`、`?`、`[]`等通配符。

    ```
    $ myPath=/home/cam/book/long.file.name
    
    $ echo ${myPath#/*/}
    cam/book/long.file.name
    
    $ echo ${myPath##/*/}
    long.file.name
    ```

    上面例子中，匹配的模式是`/*/`，其中`*`可以匹配任意数量的字符，所以最短匹配是`/home/`，最长匹配是`/home/cam/book/`。

    下面写法可以删除文件路径的目录部分，只留下文件名。

    ```
    $ path=/home/cam/book/long.file.name
    
    $ echo ${path##*/}
    long.file.name
    ```

    上面例子中，模式`*/`匹配目录部分，所以只返回文件名。

    下面再看一个例子。

    ```
    $ phone="555-456-1414"
    $ echo ${phone#*-}
    456-1414
    $ echo ${phone##*-}
    1414
    ```

    如果匹配不成功，则返回原始字符串。

    ```
    $ phone="555-456-1414"
    $ echo ${phone#444}
    555-456-1414
    ```

    上面例子中，原始字符串里面无法匹配模式`444`，所以原样返回。

    如果要将头部匹配的部分，替换成其他内容，采用下面的写法。

    ```
    # 模式必须出现在字符串的开头
    ${variable/#pattern/string}
    
    # 示例
    $ foo=JPG.JPG
    $ echo ${foo/#JPG/jpg}
    jpg.JPG
    ```

    上面例子中，被替换的`JPG`必须出现在字符串头部，所以返回`jpg.JPG`。

    **（2）字符串尾部的模式匹配。**

    以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。

    ```
    # 如果 pattern 匹配变量 variable 的结尾，
    # 删除最短匹配（非贪婪匹配）的部分，返回剩余部分
    ${variable%pattern}
    
    # 如果 pattern 匹配变量 variable 的结尾，
    # 删除最长匹配（贪婪匹配）的部分，返回剩余部分
    ${variable%%pattern}
    ```

    上面两种语法会删除变量字符串结尾的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。

    ```
    $ path=/home/cam/book/long.file.name
    
    $ echo ${path%.*}
    /home/cam/book/long.file
    
    $ echo ${path%%.*}
    /home/cam/book/long
    ```

    上面例子中，匹配模式是`.*`，其中`*`可以匹配任意数量的字符，所以最短匹配是`.name`，最长匹配是`.file.name`。

    下面写法可以删除路径的文件名部分，只留下目录部分。

    ```
    $ path=/home/cam/book/long.file.name
    
    $ echo ${path%/*}
    /home/cam/book
    ```

    上面例子中，模式`/*`匹配文件名部分，所以只返回目录部分。

    下面的写法可以替换文件的后缀名。

    ```
    $ file=foo.png
    $ echo ${file%.png}.jpg
    foo.jpg
    ```

    上面的例子将文件的后缀名，从`.png`改成了`.jpg`。

    下面再看一个例子。

    ```
    $ phone="555-456-1414"
    $ echo ${phone%-*}
    555-456
    $ echo ${phone%%-*}
    555
    ```

    如果匹配不成功，则返回原始字符串。

    如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。

    ```
    # 模式必须出现在字符串的结尾
    ${variable/%pattern/string}
    
    # 示例
    $ foo=JPG.JPG
    $ echo ${foo/%JPG/jpg}
    JPG.jpg
    ```

    上面例子中，被替换的`JPG`必须出现在字符串尾部，所以返回`JPG.jpg`。

    **（3）任意位置的模式匹配。**

    以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。

    ```
    # 如果 pattern 匹配变量 variable 的一部分，
    # 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配
    ${variable/pattern/string}
    
    # 如果 pattern 匹配变量 variable 的一部分，
    # 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换
    ${variable//pattern/string}
    ```

    上面两种语法都是最长匹配（贪婪匹配）下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。

    ```
    $ path=/home/cam/foo/foo.name
    
    $ echo ${path/foo/bar}
    /home/cam/bar/foo.name
    
    $ echo ${path//foo/bar}
    /home/cam/bar/bar.name
    ```

    上面例子中，前一个命令只替换了第一个`foo`，后一个命令将两个`foo`都替换了。

    下面的例子将分隔符从`:`换成换行符。

    ```
    $ echo -e ${PATH//:/'\n'}
    /usr/local/bin
    /usr/bin
    /bin
    ...
    ```

    上面例子中，`echo`命令的`-e`参数，表示将替换后的字符串的`\n`字符，解释为换行符。

    模式部分可以使用通配符。

    ```
    $ phone="555-456-1414"
    $ echo ${phone/5?4/-}
    55-56-1414
    ```

    上面的例子将`5-4`替换成`-`。

    如果省略了`string`部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。

    ```
    $ path=/home/cam/foo/foo.name
    
    $ echo ${path/.*/}
    /home/cam/foo/foo
    ```

    上面例子中，第二个斜杠后面的`string`部分省略了，所以模式`.*`匹配的部分`.name`被删除后返回。

    前面提到过，这个语法还有两种扩展形式。

    ```bash
    # 模式必须出现在字符串的开头
    ${variable/#pattern/string}
    
    # 模式必须出现在字符串的结尾
    ${variable/%pattern/string}
    ```

  - #### 改变大小写

    下面的语法可以改变变量的大小写。

    ```
    # 转为大写
    ${varname^^}
    
    # 转为小写
    ${varname,,}
    ```

    下面是一个例子。

    ```bash
    $ foo=heLLo
    $ echo ${foo^^}
    HELLO
    $ echo ${foo,,}
    hello
    ```

- ## 算数运算

  - #### 算术表达式

    `((...))`语法可以进行整数的算术运算。

    ```
    $ ((foo = 5 + 5))
    $ echo $foo
    10
    ```

    `((...))`会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。

    ```
    $ ((2+2))
    $ (( 2+2 ))
    $ (( 2 + 2 ))
    ```

    这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是`0`，命令就算执行成功。

    ```
    $ (( 3 + 2 ))
    $ echo $?
    0
    ```

    上面例子中，`3 + 2`的结果是5，命令就算执行成功，环境变量`$?`为`0`。

    如果算术结果为`0`，命令就算执行失败。

    ```
    $ (( 3 - 3 ))
    $ echo $?
    1
    ```

    上面例子中，`3 - 3`的结果是`0`，环境变量`$?`为`1`，表示命令执行失败。

    如果要读取算术运算的结果，需要在`((...))`前面加上美元符号`$((...))`，使其变成算术表达式，返回算术运算的值。

    ```
    $ echo $((2 + 2))
    4
    ```

    `((...))`语法支持的算术运算符如下。

    - `+`：加法
    - `-`：减法
    - `*`：乘法
    - `/`：除法（整除）
    - `%`：余数
    - `**`：指数
    - `++`：自增运算（前缀或后缀）
    - `--`：自减运算（前缀或后缀）

    注意，除法运算符的返回结果总是整数，比如`5`除以`2`，得到的结果是`2`，而不是`2.5`。

    ```
    $ echo $((5 / 2))
    2
    ```

    `++`和`--`这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。

    ```
    $ i=0
    $ echo $i
    0
    $ echo $((i++))
    0
    $ echo $i
    1
    $ echo $((++i))
    2
    $ echo $i
    2
    ```

    上面例子中，`++`作为后缀是先返回值，执行`echo`命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行`echo`命令。

    `$((...))`内部可以用圆括号改变运算顺序。

    ```
    $ echo $(( (2 + 3) * 4 ))
    20
    ```

    上面例子中，内部的圆括号让加法先于乘法执行。

    `$((...))`结构可以嵌套。

    ```
    $ echo $(((5**2) * 3))
    75
    # 等同于
    $ echo $(($((5**2)) * 3))
    75
    ```

    这个语法只能计算整数，否则会报错。

    ```
    # 报错
    $ echo $((1.5 + 1))
    bash: 语法错误
    ```

    `$((...))`的圆括号之中，不需要在变量名之前加上`$`，不过加上也不报错。

    ```
    $ number=2
    $ echo $(($number + 1))
    3
    ```

    上面例子中，变量`number`前面有没有美元符号，结果都是一样的。

    如果在`$((...))`里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。

    ```
    $ echo $(( "hello" + 2))
    2
    $ echo $(( "hello" * 2))
    0
    ```

    上面例子中，`"hello"`会被当作变量名，返回空值，而`$((...))`会将空值当作`0`，所以乘法的运算结果就是`0`。同理，如果`$((...))`里面使用不存在的变量，也会当作`0`处理。

    如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在`$((...))`里面会被当作空值。

    ```
    $ foo=hello
    $ echo $(( foo + 2))
    2
    ```

    上面例子中，变量`foo`的值是`hello`，而`hello`也会被看作变量名。这使得有可能写出动态替换的代码。

    ```
    $ foo=hello
    $ hello=3
    $ echo $(( foo + 2 ))
    5
    ```

    上面代码中，`foo + 2`取决于变量`hello`的值。

    最后，`$[...]`是以前的语法，也可以做整数运算，不建议使用。

    ```bash
    $ echo $[2+2]
    4
    ```

  - #### 数值的进制

    Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。

    - `number`：没有任何特殊表示法的数字是十进制数（以10为底）。
    - `0number`：八进制数。
    - `0xnumber`：十六进制数。
    - `base#number`：`base`进制的数。

    下面是一些例子。

    ```
    $ echo $((0xff))
    255
    $ echo $((2#11111111))
    255
    ```

    上面例子中，`0xff`是十六进制数，`2#11111111`是二进制数。

  - #### 位运算

    `$((...))`支持以下的二进制位运算符。

    - `<<`：位左移运算，把一个数字的所有位向左移动指定的位。
    - `>>`：位右移运算，把一个数字的所有位向右移动指定的位。
    - `&`：位的“与”运算，对两个数字的所有位执行一个`AND`操作。
    - `|`：位的“或”运算，对两个数字的所有位执行一个`OR`操作。
    - `~`：位的“否”运算，对一个数字的所有位取反。
    - `^`：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。

    下面是右移运算符`>>`的例子。

    ```
    $ echo $((16>>2))
    4
    ```

    下面是左移运算符`<<`的例子。

    ```
    $ echo $((16<<2))
    64
    ```

    下面是`17`（二进制`10001`）和`3`（二进制`11`）的各种二进制运算的结果。

    ```bash
    $ echo $((17&3))
    1
    $ echo $((17|3))
    19
    $ echo $((17^3))
    18
    ```

  - #### 逻辑运算

    `$((...))`支持以下的逻辑运算符。

    - `<`：小于
    - `>`：大于
    - `<=`：小于或相等
    - `>=`：大于或相等
    - `==`：相等
    - `!=`：不相等
    - `&&`：逻辑与
    - `||`：逻辑或
    - `!`：逻辑否
    - `expr1?expr2:expr3`：三元条件运算符。若表达式`expr1`的计算结果为非零值（算术真），则执行表达式`expr2`，否则执行表达式`expr3`。

    如果逻辑表达式为真，返回`1`，否则返回`0`。

    ```
    $ echo $((3 > 2))
    1
    $ echo $(( (3 > 2) || (4 <= 1) ))
    1
    ```

    三元运算符执行一个单独的逻辑测试。它用起来类似于`if/then/else`语句。

    ```
    $ a=0
    $ echo $((a<1 ? 1 : 0))
    1
    $ echo $((a>1 ? 1 : 0))
    0
    ```

    上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。

  - #### 赋值运算

    算术表达式`$((...))`可以执行赋值运算。

    ```
    $ echo $((a=1))
    1
    $ echo $a
    1
    ```

    上面例子中，`a=1`对变量`a`进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。

    `$((...))`支持的赋值运算符，有以下这些。

    - `parameter = value`：简单赋值。
    - `parameter += value`：等价于`parameter = parameter + value`。
    - `parameter -= value`：等价于`parameter = parameter – value`。
    - `parameter *= value`：等价于`parameter = parameter * value`。
    - `parameter /= value`：等价于`parameter = parameter / value`。
    - `parameter %= value`：等价于`parameter = parameter % value`。
    - `parameter <<= value`：等价于`parameter = parameter << value`。
    - `parameter >>= value`：等价于`parameter = parameter >> value`。
    - `parameter &= value`：等价于`parameter = parameter & value`。
    - `parameter |= value`：等价于`parameter = parameter | value`。
    - `parameter ^= value`：等价于`parameter = parameter ^ value`。

    下面是一个例子。

    ```
    $ foo=5
    $ echo $((foo*=2))
    10
    ```

    如果在表达式内部赋值，可以放在圆括号中，否则会报错。

    ```bash
    $ echo $(( a<1 ? (a+=1) : (a-=1) ))
    ```

  - #### 求值运算

    逗号`,`在`$((...))`内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。

    ```
    $ echo $((foo = 1 + 2, 3 * 4))
    12
    $ echo $foo
    3
    ```

    上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值`12`。

  - #### expr 命令

    `expr`命令支持算术运算，可以不使用`((...))`语法。

    ```
    $ expr 3 + 2
    5
    ```

    `expr`命令支持变量替换。

    ```
    $ foo=3
    $ expr $foo + 2
    5
    ```

    `expr`命令也不支持非整数参数。

    ```
    $ expr 3.5 + 2
    expr: 非整数参数
    ```

    上面例子中，如果有非整数的运算，`expr`命令就报错了。

  - #### let 命令

    `let`命令用于将算术运算的结果，赋予一个变量。

    ```
    $ let x=2+3
    $ echo $x
    5
    ```

    上面例子中，变量`x`等于`2+3`的运算结果。

    注意，`x=2+3`这个式子里面不能有空格，否则会报错。`let`命令的详细用法参见《变量》一章。

- ## 操作历史

  - #### 简介

    Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录，默认是保存最近的500条命令。有了操作历史以后，就可以使用方向键的`↑`和`↓`，快速浏览上一条和下一条命令。

    退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入`~/.bash_history`文件，该文件默认储存500个操作。

    环境变量`HISTFILE`总是指向这个文件。

    ```bash
    $ echo $HISTFILE
    /home/me/.bash_history
    ```

  - #### history 命令

    `history`命令会输出`.bash_history`文件的全部内容，即输出操作历史。

    ```
    $ history
    ...
    498 echo Goodbye
    499 ls ~
    500 cd
    ```

    用户可以使用这个命令，查看最近的操作。相比直接读取`.bash_history`文件，它的优势在于所有命令之前加上了行号。最近的操作在最后面，行号最大。

    如果想搜索某个以前执行的命令，可以配合`grep`命令搜索操作历史。

    ```
    $ history | grep /usr/bin
    ```

    上面命令返回`.bash_history`文件里面，那些包含`/usr/bin`的命令。

    `history`命令的`-c`参数可以清除操作历史，即清空`.bash_history`文件。

    ```bash
    $ history -c
    ```

  - #### 环境变量

    - ##### HISTTIMEFORMAT

      通过定制环境变量`HISTTIMEFORMAT`，`history`的输出结果还可以显示每个操作的时间。

      ```
      $ export HISTTIMEFORMAT='%F %T  '
      $ history
      1  2013-06-09 10:40:12   cat /etc/issue
      2  2013-06-09 10:40:12   clear
      ```

      上面代码中，`%F`相当于`%Y - %m - %d`（年-月-日），`%T`相当于`%H : %M : %S`（时:分:秒）。

      只要设置`HISTTIMEFORMAT`这个环境变量，就会在`.bash_history`文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。

    - ##### HISTSIZE

      环境变量`HISTSIZE`设置保存历史操作的数量。

      ```
      $ export HISTSIZE=10000
      ```

      上面命令设置保存过去10000条操作历史。

      如果不希望保存本次操作的历史，可以设置`HISTSIZE`等于0。

      ```
      export HISTSIZE=0
      ```

      如果`HISTSIZE=0`写入用户主目录的`~/.bashrc`文件，那么就不会保留该用户的操作历史。如果写入`/etc/profile`，整个系统都不会保留操作历史。

    - ##### HISTIGNORE

      环境变量`HISTIGNORE`可以设置哪些命令不写入操作历史。

      ```
      export HISTIGNORE='pwd:ls:exit'
      ```

      上面示例设置，`pwd`、`ls`、`exit`这三个命令不写入操作历史。

  - #### Ctrl + r

    输入命令时，按下`Ctrl + r`快捷键，就可以搜索操作历史，选择以前执行过的命令。

    `Ctrl + r`相当于打开一个`.bash_history`文件的搜索接口，直接键入命令的开头部分，Shell 就会自动在该文件中反向查询（即先查询最近的命令），显示最近一条匹配的结果，这时按下回车键，就会执行那条命令。

  - #### ! 命令

    - ##### ! + 行号

      操作历史的每一条记录都有行号。知道了命令的行号以后，可以用`感叹号 + 行号`执行该命令。如果想要执行`.bash_history`里面的第8条命令，可以像下面这样操作。

      ```bash
      $ !8
      ```

    - ##### !- 数字

      如果想执行本次 Shell 对话中倒数的命令，比如执行倒数第3条命令，就可以输入`!-3`。

      ```
      $ touch a.txt
      $ touch b.txt
      $ touch c.txt
      
      $ !-3
      touch a.txt
      ```

      上面示例中，`!-3`返回倒数第3条命令，即`touch a.txt`。

      它跟`! + 行号`的主要区别是，后者是在`.bash_history`文件中从头开始计算行数，而`!- 数字`是从底部开始向上计算行数。

    - ##### !!

      `!!`命令返回上一条命令。如果需要重复执行某一条命令，就可以不断键入`!!`，这样非常方便。它等同于`!-1`。

      ```
      $ echo hello
      hello
      
      $ !!
      echo hello
      hello
      ```

      上面示例中，`!!`会返回并执行上一条命令`echo hello`。

      有时候，我们使用某条命令，系统报错没有权限，这时就可以使用`sudo !!`。

      ```
      # 报错，没有执行权限
      $ yum update
      
      $ sudo !!
      sudo yum update
      ```

      上面示例中，`sudo !!`返回`sudo yum update`，从而就可以正确执行了。

    - ##### ! + 搜索词

      `感叹号 + 搜索词`可以快速执行匹配的命令。

      ```
      $ echo Hello World
      Hello World
      
      $ echo Goodbye
      Goodbye
      
      $ !e
      echo Goodbye
      Goodbye
      ```

      上面例子中，`!e`表示找出操作历史之中，最近的那一条以`e`开头的命令并执行。Bash 会先输出那一条命令`echo Goodbye`，然后直接执行。

      同理，`!echo`也会执行最近一条以`echo`开头的命令。

      ```
      $ !echo
      echo Goodbye
      Goodbye
      
      $ !echo H
      echo Goodbye H
      Goodbye H
      
      $ !echo H G
      echo Goodbye H G
      Goodbye H G
      ```

      注意，`感叹号 + 搜索词`语法只会匹配命令，不会匹配参数。所以`!echo H`不会执行`echo Hello World`，而是会执行`echo Goodbye`，并把参数`H`附加在这条命令之后。同理，`!echo H G`也是等同于`echo Goodbye`命令之后附加`H G`。

      由于`感叹号 + 搜索词`会扩展成以前执行过的命令，所以含有`!`的字符串放在双引号里面，必须非常小心，如果它后面有非空格的字符，就很有可能报错。

      ```
      $ echo "I say:\"hello!\""
      bash: !\: event not found
      ```

      上面的命令会报错，原因是感叹号后面是一个反斜杠，Bash 会尝试寻找，以前是否执行过反斜杠开头的命令，一旦找不到就会报错。解决方法就是在感叹号前面，也加上反斜杠。

      ```bash
      $ echo "I say:\"hello\!\""
      I say:"hello\!"
      ```

    - ##### !? + 搜索词

      `!? + 搜索词`可以搜索命令的任意部分，包括参数部分。它跟`! + 搜索词`的主要区别是，后者是从行首开始匹配。

      ```
      $ cat hello.txt
      Hello world ..!
      
      $ !?hello.txt
      cat hello.txt
      Hello world ..!
      ```

      上面示例中，`!?hello.txt`会返回最近一条包括`hello.txt`的命令。

    - ##### !$，!*

      `!$`代表上一个命令的最后一个参数，它的另一种写法是`$_`。

      `!*`代表上一个命令的所有参数，即除了命令以外的所有部分。

      ```
      $ cp a.txt b.txt
      $ echo !$
      b.txt
      
      $ cp a.txt b.txt
      $ echo !*
      a.txt b.txt
      ```

      上面示例中，`!$`代表上一个命令的最后一个参数（`b.txt`），`!*`代表上一个命令的所有参数（`a.txt b.txt`）。

      如果想匹配上一个命令的某个指定位置的参数，使用`!:n`。

      ```
      $ ls a.txt b.txt c.txt
      
      $ echo !:2
      b.txt
      ```

      上面示例中，`!:2`返回上一条命令的第二个参数（`b.txt`）。

      这种写法的`!:$`，代表上一个命令的最后一个参数。事实上，`!$`就是`!:$`的简写形式。

      ```
      $ ls a.txt b.txt c.txt
      
      $ echo !:$
      echo c.txt
      c.txt
      ```

      上面示例中，`!:$`代表上一条命令的最后一个参数（`c.txt`）。

      如果想匹配更久以前的命令的参数，可以使用`!<命令>:n`（指定位置的参数）和`!<命令>:$`（最后一个参数）。

      ```
      $ ls !mkdir:$
      ```

      上面示例中，`!mkdir:$`会返回前面最后一条`mkdir`命令的最后一个参数。

      ```
      $ ls !mk:2
      ```

      上面示例中，`!mk:2`会返回前面最后一条以`mk`开头的命令的第二个参数。

    - ##### !:p

      如果只是想输出上一条命令，而不是执行它，可以使用`!:p`。

      ```
      $ echo hello
      
      $ !:p
      echo hello
      ```

      上面示例中，`!:p`只会输出`echo hello`，而不会执行这条命令。

      如果想输出最近一条匹配的命令，而不执行它，可以使用`!<命令>:p`。

      ```
      $ !su:p
      ```

      上面示例中，`!su:p`会输出前面最近一条以`su`开头的命令，而不执行它。

  - #### ^string1^string2

    `^string1^string2`用来执行最近一条包含`string1`的命令，将其替换成`string2`。

    ```bash
    $ rm /var/log/httpd/error.log
    $ ^error^access
    rm /var/log/httpd/access.log
    ```

    上面示例中，`^error^access`将最近一条含有`error`的命令里面的`error`，替换成`access`。

  - #### histverify 参数

    上面的那些快捷命令（比如`!!`命令），都是找到匹配的命令后，直接执行。如果希望增加一个确认步骤，先输出是什么命令，让用户确认后再执行，可以打开 Shell 的`histverify`选项。

    ```bash
    $ shopt -s histverify
    ```

    打开`histverify`这个选项后，使用`!`快捷键所返回的命令，就会先输出，等到用户按下回车键后再执行。

  - #### 快捷键

    下面是其他一些与操作历史相关的快捷键。

    - `Ctrl + p`：显示上一个命令，与向上箭头效果相同（previous）。
    - `Ctrl + n`：显示下一个命令，与向下箭头效果相同（next）。
    - `Alt + <`：显示第一个命令。
    - `Alt + >`：显示最后一个命令，即当前的命令。
    - `Ctrl + o`：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。

