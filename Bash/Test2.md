## 引号和转义

> Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。

- #### 转义

  某些字符在 Bash 里面有特殊含义（比如`$`、`&`、`*`）。

  ```
  $ echo $date
  
  $
  ```

  上面例子中，输出`$date`不会有任何结果，因为`$`是一个特殊字符。

  如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。

  ```
  $ echo \$date
  $date
  ```

  上面命令中，只有在特殊字符`$`前面加反斜杠，才能原样输出。

  反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（`\\`）。

  ```
  $ echo \\
  \
  ```

  上面例子输出了反斜杠本身。

  反斜杠除了用于转义，还可以表示一些不可打印的字符。

  - `\a`：响铃
  - `\b`：退格
  - `\n`：换行
  - `\r`：回车
  - `\t`：制表符

  如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用`echo`命令的`-e`参数。

  ```
  $ echo a\tb
  atb
  
  $ echo -e "a\tb"
  a        b
  ```

  上面例子中，命令行直接输出不可打印字符`\t`，Bash 不能正确解释。必须把它们放在引号之中，然后使用`echo`命令的`-e`参数。

  换行符是一个特殊字符，表示命令的结束，Bash 收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作长度为`0`的空字符处理，从而可以将一行命令写成多行。

  ```
  $ mv \
  /path/to/foo \
  /path/to/bar
  
  # 等同于
  $ mv /path/to/foo /path/to/bar
  ```

  上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。

- #### 单引号

  Bash 允许字符串放在单引号或双引号之中，加以引用。

  单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（`*`）、美元符号（`$`）、反斜杠（`\`）等。

  ```
  $ echo '*'
  *
  
  $ echo '$USER'
  $USER
  
  $ echo '$((2+2))'
  $((2+2))
  
  $ echo '$(echo foo)'
  $(echo foo)
  ```

  上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。

  由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（`$`），然后再对里层的单引号转义。

  ```
  # 不正确
  $ echo it's
  
  # 不正确
  $ echo 'it\'s'
  
  # 正确
  $ echo $'it\'s'
  ```

  不过，更合理的方法是改在双引号之中使用单引号。

  ```bash
  $ echo "it's"
  it's
  ```

- #### 双引号

  双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。

  ```
  $ echo "*"
  *
  ```

  上面例子中，通配符`*`是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。

  但是，三个特殊字符除外：美元符号（`$`）、反引号（```）和反斜杠（`\`）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。

  ```
  $ echo "$SHELL"
  /bin/bash
  
  $ echo "`date`"
  Mon Jan 27 13:33:18 CST 2020
  ```

  上面例子中，美元符号（`$`）和反引号（```）在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。

  ```
  $ echo "I'd say: \"hello.\""
  I'd say: "hello."
  
  $ echo "\\"
  \
  ```

  上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。

  换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。

  ```
  $ echo "hello
  world"
  hello
  world
  ```

  上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就失去了这种特殊作用，只用来换行，所以可以输入多行。`echo`命令会将换行符原样输出，显示的时候正常解释为换行。

  双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号（或单引号），将文件名放在里面。

  ```
  $ ls "two words.txt"
  ```

  上面命令中，`two words.txt`是一个包含空格的文件名，如果不放在双引号里面，就会被 Bash 当作两个文件。

  双引号会原样保存多余的空格。

  ```
  $ echo "this is a     test"
  this is a     test
  ```

  双引号还有一个作用，就是保存原始命令的输出格式。

  ```
  # 单行输出
  $ echo $(cal)
  一月 2020 日 一 二 三 四 五 六 1 2 3 ... 31
  
  # 原始格式输出
  $ echo "$(cal)"
        一月 2020
  日 一 二 三 四 五 六
            1  2  3  4
   5  6  7  8  9 10 11
  12 13 14 15 16 17 18
  19 20 21 22 23 24 25
  26 27 28 29 30 31
  ```

  上面例子中，如果`$(cal)`不放在双引号之中，`echo`就会将所有结果以单行输出，丢弃了所有原始的格式。

- #### Here 文档

  Here 文档（here document）是一种输入多行字符串的方法，格式如下。

  ```
  << token
  text
  token
  ```

  它的格式分成开始标记（`<< token`）和结束标记（`token`）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。

  下面是一个通过 Here 文档输出 HTML 代码的例子。

  ```
  $ cat << _EOF_
  <html>
  <head>
      <title>
      The title of your page
      </title>
  </head>
  
  <body>
      Your page content goes here.
  </body>
  </html>
  _EOF_
  ```

  Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。

  ```
  $ foo='hello world'
  $ cat << _example_
  $foo
  "$foo"
  '$foo'
  _example_
  
  hello world
  "hello world"
  'hello world'
  ```

  上面例子中，变量`$foo`发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。

  如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。

  ```
  $ foo='hello world'
  $ cat << '_example_'
  $foo
  "$foo"
  '$foo'
  _example_
  
  $foo
  "$foo"
  '$foo'
  ```

  上面例子中，Here 文档的开始标记（`_example_`）放在单引号之中，导致变量替换失效了。

  Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了`echo`命令。

  ```
  $ command << token
    string
  token
  
  # 等同于
  
  $ echo string | command
  ```

  上面代码中，Here 文档相当于`echo`命令的重定向。

  所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如`echo`命令就不能用 Here 文档作为参数。

  ```
  $ echo << _example_
  hello
  _example_
  ```

  上面例子不会有任何输出，因为 Here 文档对于`echo`命令无效。

  此外，Here 文档也不能作为变量的值，只能用于命令的参数。

- #### Here 字符串

  Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（`<<<`）表示。

  ```
  <<< string
  ```

  它的作用是将字符串通过标准输入，传递给命令。

  有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如`cat`命令只接受标准输入传入的字符串。

  ```
  $ cat <<< 'hi there'
  # 等同于
  $ echo 'hi there' | cat
  ```

  上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。

  ```
  $ md5sum <<< 'ddd'
  # 等同于
  $ echo 'ddd' | md5sum
  ```

  上面例子中，`md5sum`命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即`md5sum ddd`里面的`ddd`会被解释成文件名。这时就可以用 Here 字符串，将字符串传给`md5sum`命令。

## 变量

- #### 简介

  > Bash 变量分成环境变量和自定义变量两类。

  - ##### 环境变量

    环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。

    `env`命令或`printenv`命令，可以显示所有环境变量。

    ```
    $ env
    # 或者
    $ printenv
    ```

    下面是一些常见的环境变量。

    - `BASHPID`：Bash 进程的进程 ID。
    - `BASHOPTS`：当前 Shell 的参数，可以用`shopt`命令修改。
    - `DISPLAY`：图形环境的显示器名字，通常是`:0`，表示 X Server 的第一个显示器。
    - `EDITOR`：默认的文本编辑器。
    - `HOME`：用户的主目录。
    - `HOST`：当前主机的名称。
    - `IFS`：词与词之间的分隔符，默认为空格。
    - `LANG`：字符集以及语言编码，比如`zh_CN.UTF-8`。
    - `PATH`：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。
    - `PS1`：Shell 提示符。
    - `PS2`： 输入多行命令时，次要的 Shell 提示符。
    - `PWD`：当前工作目录。
    - `RANDOM`：返回一个0到32767之间的随机数。
    - `SHELL`：Shell 的名字。
    - `SHELLOPTS`：启动当前 Shell 的`set`命令的参数，参见《set 命令》一章。
    - `TERM`：终端类型名，即终端仿真器所用的协议。
    - `UID`：当前用户的 ID 编号。
    - `USER`：当前用户的用户名。

    很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。

    注意，Bash 变量名区分大小写，`HOME`和`home`是两个不同的变量。

    查看单个环境变量的值，可以使用`printenv`命令或`echo`命令。

    ```
    $ printenv PATH
    # 或者
    $ echo $PATH
    ```

    注意，`printenv`命令后面的变量名，不用加前缀`$`。

  - ##### 自定义变量

    自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。

    `set`命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。

    ```bash
    $ set
    ```

- #### 创建变量

  用户创建变量的时候，变量名必须遵守下面的规则。

  - 字母、数字和下划线字符组成。
  - 第一个字符必须是一个字母或一个下划线，不能是数字。
  - 不允许出现空格和标点符号。

  变量声明的语法如下。

  ```
  variable=value
  ```

  上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。

  如果变量的值包含空格，则必须将值放在引号中。

  ```
  myvar="hello world"
  ```

  Bash 没有数据类型的概念，所有的变量值都是字符串。

  下面是一些自定义变量的例子。

  ```
  a=z                     # 变量 a 赋值为字符串 z
  b="a string"            # 变量值包含空格，就必须放在引号里面
  c="a string and $b"     # 变量值可以引用其他变量的值
  d="\t\ta string\n"      # 变量值可以使用转义字符
  e=$(ls -l foo.txt)      # 变量值可以是命令的执行结果
  f=$((5 * 7))            # 变量值可以是数学运算的结果
  ```

  变量可以重复赋值，后面的赋值会覆盖前面的赋值。

  ```
  $ foo=1
  $ foo=2
  $ echo $foo
  2
  ```

  上面例子中，变量`foo`的第二次赋值会覆盖第一次赋值。

  如果同一行定义多个变量，必须使用分号（`;`）分隔。

  ```
  $ foo=1;bar=2
  ```

  上面例子中，同一行定义了`foo`和`bar`两个变量。

- #### 读取变量

  读取变量的时候，直接在变量名前加上`$`就可以了。

  ```
  $ foo=bar
  $ echo $foo
  bar
  ```

  每当 Shell 看到以`$`开头的单词时，就会尝试读取这个变量名对应的值。

  如果变量不存在，Bash 不会报错，而会输出空字符。

  由于`$`在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，

  ```
  $ echo The total is $100.00
  The total is 00.00
  ```

  上面命令的原意是输入`$100`，但是 Bash 将`$1`解释成了变量，该变量为空，因此输入就变成了`00.00`。所以，如果要使用`$`的原义，需要在`$`前面放上反斜杠，进行转义。

  ```
  $ echo The total is \$100.00
  The total is $100.00
  ```

  读取变量的时候，变量名也可以使用花括号`{}`包围，比如`$a`也可以写成`${a}`。这种写法可以用于变量名与其他字符连用的情况。

  ```
  $ a=foo
  $ echo $a_file
  
  $ echo ${a}_file
  foo_file
  ```

  上面代码中，变量名`a_file`不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分`$a`，Bash 才能正确解读。

  事实上，读取变量的语法`$foo`，可以看作是`${foo}`的简写形式。

  如果变量的值本身也是变量，可以使用`${!varname}`的语法，读取最终的值。

  ```
  $ myvar=USER
  $ echo ${!myvar}
  ruanyf
  ```

  上面的例子中，变量`myvar`的值是`USER`，`${!myvar}`的写法将其展开成最终的值。

  如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。

  ```
  $ a="1 2  3"
  $ echo $a
  1 2 3
  $ echo "$a"
  1 2  3
  ```

  上面示例中，变量`a`的值包含两个连续空格。如果直接读取，Shell 会将连续空格合并成一个。只有放在双引号里面读取，才能保持原来的格式。

- #### 删除变量

  `unset`命令用来删除一个变量。

  ```
  unset NAME
  ```

  这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使`unset`命令删除了变量，还是可以读取这个变量，值为空字符串。

  所以，删除一个变量，也可以将这个变量设成空字符串。

  ```
  $ foo=''
  $ foo=
  ```

  上面两种写法，都是删除了变量`foo`。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。

- #### 输出变量，`export` 命令

  用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用`export`命令。这样输出的变量，对于子 Shell 来说就是环境变量。

  `export`命令用来向子 Shell 输出变量。

  ```
  NAME=foo
  export NAME
  ```

  上面命令输出了变量`NAME`。变量的赋值和输出也可以在一个步骤中完成。

  ```
  export NAME=value
  ```

  上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量`$NAME`。

  子 Shell 如果修改继承的变量，不会影响父 Shell。

  ```
  # 输出变量 $foo
  $ export foo=bar
  
  # 新建子 Shell
  $ bash
  
  # 读取 $foo
  $ echo $foo
  bar
  
  # 修改继承的变量
  $ foo=baz
  
  # 退出子 Shell
  $ exit
  
  # 读取 $foo
  $ echo $foo
  bar
  ```

  上面例子中，子 Shell 修改了继承的变量`$foo`，对父 Shell 没有影响。

- #### 特殊变量

  Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。

  （1）`$?`

  `$?`为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是`0`，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。

  ```
  $ ls doesnotexist
  ls: doesnotexist: No such file or directory
  
  $ echo $?
  1
  ```

  上面例子中，`ls`命令查看一个不存在的文件，导致报错。`$?`为1，表示上一个命令执行失败。

  （2）`$$`

  `$$`为当前 Shell 的进程 ID。

  ```
  $ echo $$
  10662
  ```

  这个特殊变量可以用来命名临时文件。

  ```
  LOGFILE=/tmp/output_log.$$
  ```

  （3）`$_`

  `$_`为上一个命令的最后一个参数。

  ```
  $ grep dictionary /usr/share/dict/words
  dictionary
  
  $ echo $_
  /usr/share/dict/words
  ```

  （4）`$!`

  `$!`为最近一个后台执行的异步命令的进程 ID。

  ```
  $ firefox &
  [1] 11064
  
  $ echo $!
  11064
  ```

  上面例子中，`firefox`是后台运行的命令，`$!`返回该命令的进程 ID。

  （5）`$0`

  `$0`为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。

  ```
  $ echo $0
  bash
  ```

  上面例子中，`$0`返回当前运行的是 Bash。

  （6）`$-`

  `$-`为当前 Shell 的启动参数。

  ```
  $ echo $-
  himBHs
  ```

  （7）`$@`和`$#`

  `$#`表示脚本的参数数量，`$@`表示脚本的参数值，参见脚本一章。

- #### 变量的默认值

  Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。

  ```
  ${varname:-word}
  ```

  上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则返回`word`。它的目的是返回一个默认值，比如`${count:-0}`表示变量`count`不存在时返回`0`。

  ```
  ${varname:=word}
  ```

  上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则将它设为`word`，并且返回`word`。它的目的是设置变量的默认值，比如`${count:=0}`表示变量`count`不存在时返回`0`，且将`count`设为`0`。

  ```
  ${varname:+word}
  ```

  上面语法的含义是，如果变量名存在且不为空，则返回`word`，否则返回空值。它的目的是测试变量是否存在，比如`${count:+1}`表示变量`count`存在时返回`1`（表示`true`），否则返回空值。

  ```
  ${varname:?message}
  ```

  上面语法的含义是，如果变量`varname`存在且不为空，则返回它的值，否则打印出`varname: message`，并中断脚本的执行。如果省略了`message`，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如`${count:?"undefined!"}`表示变量`count`未定义时就中断执行，抛出错误，返回给定的报错信息`undefined!`。

  上面四种语法如果用在脚本中，变量名的部分可以用数字`1`到`9`，表示脚本的参数。

  ```
  filename=${1:?"filename missing."}
  ```

  上面代码出现在脚本中，`1`表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。

- #### `declare` 命令

  `declare`命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。

  它的语法形式如下。

  ```
  declare OPTION VARIABLE=value
  ```

  `declare`命令的主要参数（OPTION）如下。

  - `-a`：声明数组变量。
  - `-f`：输出所有函数定义。
  - `-F`：输出所有函数名。
  - `-i`：声明整数变量。
  - `-l`：声明变量为小写字母。
  - `-p`：查看变量信息。
  - `-r`：声明只读变量。
  - `-u`：声明变量为大写字母。
  - `-x`：该变量输出为环境变量。

  `declare`命令如果用在函数中，声明的变量只在函数内部有效，等同于`local`命令。

  不带任何参数时，`declare`命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的`set`命令。

  ```
  $ declare
  ```

  **（1）`-i`参数**

  `-i`参数声明整数变量以后，可以直接进行数学运算。

  ```
  $ declare -i val1=12 val2=5
  $ declare -i result
  $ result=val1*val2
  $ echo $result
  60
  ```

  上面例子中，如果变量`result`不声明为整数，`val1*val2`会被当作字面量，不会进行整数运算。另外，`val1`和`val2`其实不需要声明为整数，因为只要`result`声明为整数，它的赋值就会自动解释为整数运算。

  注意，一个变量声明为整数以后，依然可以被改写为字符串。

  ```
  $ declare -i var=12
  $ var=foo
  $ echo $var
  0
  ```

  上面例子中，变量`var`声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出0，也可能输出的是3。

  **（2）`-x`参数**

  `-x`参数等同于`export`命令，可以输出一个变量为子 Shell 的环境变量。

  ```
  $ declare -x foo
  # 等同于
  $ export foo
  ```

  **（3）`-r`参数**

  `-r`参数可以声明只读变量，无法改变变量值，也不能`unset`变量。

  ```
  $ declare -r bar=1
  
  $ bar=2
  bash: bar：只读变量
  $ echo $?
  1
  
  $ unset bar
  bash: bar：只读变量
  $ echo $?
  1
  ```

  上面例子中，后两个赋值语句都会报错，命令执行失败。

  **（4）`-u`参数**

  `-u`参数声明变量为大写字母，可以自动把变量值转成大写字母。

  ```
  $ declare -u foo
  $ foo=upper
  $ echo $foo
  UPPER
  ```

  **（5）`-l`参数**

  `-l`参数声明变量为小写字母，可以自动把变量值转成小写字母。

  ```
  $ declare -l bar
  $ bar=LOWER
  $ echo $bar
  lower
  ```

  **（6）`-p`参数**

  `-p`参数输出变量信息。

  ```
  $ foo=hello
  $ declare -p foo
  declare -- foo="hello"
  $ declare -p bar
  bar：未找到
  ```

  上面例子中，`declare -p`可以输出已定义变量的值，对于未定义的变量，会提示找不到。

  如果不提供变量名，`declare -p`输出所有变量的信息。

  ```
  $ declare -p
  ```

  **（7）`-f`参数**

  `-f`参数输出当前环境的所有函数，包括它的定义。

  ```
  $ declare -f
  ```

  **（8）`-F`参数**

  `-F`参数输出当前环境的所有函数名，不包含函数定义。

  ```bash
  $ declare -F
  ```

- #### `readonly` 命令

  `readonly`命令等同于`declare -r`，用来声明只读变量，不能改变变量值，也不能`unset`变量。

  ```
  $ readonly foo=1
  $ foo=2
  bash: foo：只读变量
  $ echo $?
  1
  ```

  上面例子中，更改只读变量`foo`会报错，命令执行失败。

  `readonly`命令有三个参数。

  - `-f`：声明的变量为函数名。
  - `-p`：打印出所有的只读变量。
  - `-a`：声明的变量为数组。

- #### `let` 命令

  `let`命令声明变量时，可以直接执行算术表达式。

  ```
  $ let foo=1+2
  $ echo $foo
  3
  ```

  上面例子中，`let`命令可以直接计算`1 + 2`。

  `let`命令的参数表达式如果包含空格，就需要使用引号。

  ```
  $ let "foo = 1 + 2"
  ```

  `let`可以同时对多个变量赋值，赋值表达式之间使用空格分隔。

  ```
  $ let "v1 = 1" "v2 = v1++"
  $ echo $v1,$v2
  2,1
  ```

  上面例子中，`let`声明了两个变量`v1`和`v2`，其中`v2`等于`v1++`，表示先返回`v1`的值，然后`v1`自增。

  这种语法支持的运算符，参考《Bash 的算术运算》一章。

## 字符串操作

> 本章介绍 Bash 字符串操作的语法。

- #### 字符串的长度

  获取字符串长度的语法如下。

  ```
  ${#varname}
  ```

  下面是一个例子。

  ```
  $ myPath=/home/cam/book/long.file.name
  $ echo ${#myPath}
  29
  ```

  大括号`{}`是必需的，否则 Bash 会将`$#`理解成脚本的参数个数，将变量名理解成文本。

  ```
  $ echo $#myvar
  0myvar
  ```

  上面例子中，Bash 将`$#`和`myvar`分开解释了。

- #### 子字符串

  字符串提取子串的语法如下。

  ```
  ${varname:offset:length}
  ```

  上面语法的含义是返回变量`$varname`的子字符串，从位置`offset`开始（从`0`开始计算），长度为`length`。

  ```
  $ count=frogfootman
  $ echo ${count:4:4}
  foot
  ```

  上面例子返回字符串`frogfootman`从4号位置开始的长度为4的子字符串`foot`。

  这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。

  ```
  # 报错
  $ echo ${"hello":2:3}
  ```

  上面例子中，`"hello"`不是变量名，导致 Bash 报错。

  如果省略`length`，则从位置`offset`开始，一直返回到字符串的结尾。

  ```
  $ count=frogfootman
  $ echo ${count:4}
  footman
  ```

  上面例子是返回变量`count`从4号位置一直到结尾的子字符串。

  如果`offset`为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与`${variable:-word}`的变量的设置默认值语法混淆。这时还可以指定`length`，`length`可以是正值，也可以是负值（负值不能超过`offset`的长度）。

  ```
  $ foo="This string is long."
  $ echo ${foo: -5}
  long.
  $ echo ${foo: -5:2}
  lo
  $ echo ${foo: -5:-2}
  lon
  ```

  上面例子中，`offset`为`-5`，表示从倒数第5个字符开始截取，所以返回`long.`。如果指定长度`length`为`2`，则返回`lo`；如果`length`为`-2`，表示要排除从字符串末尾开始的2个字符，所以返回`lon`。

- #### 搜索和替换

  Bash 提供字符串搜索和替换的多种方法。

  **（1）字符串头部的模式匹配。**

  以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。

  ```
  # 如果 pattern 匹配变量 variable 的开头，
  # 删除最短匹配（非贪婪匹配）的部分，返回剩余部分
  ${variable#pattern}
  
  # 如果 pattern 匹配变量 variable 的开头，
  # 删除最长匹配（贪婪匹配）的部分，返回剩余部分
  ${variable##pattern}
  ```

  上面两种语法会删除变量字符串开头的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。

  匹配模式`pattern`可以使用`*`、`?`、`[]`等通配符。

  ```
  $ myPath=/home/cam/book/long.file.name
  
  $ echo ${myPath#/*/}
  cam/book/long.file.name
  
  $ echo ${myPath##/*/}
  long.file.name
  ```

  上面例子中，匹配的模式是`/*/`，其中`*`可以匹配任意数量的字符，所以最短匹配是`/home/`，最长匹配是`/home/cam/book/`。

  下面写法可以删除文件路径的目录部分，只留下文件名。

  ```
  $ path=/home/cam/book/long.file.name
  
  $ echo ${path##*/}
  long.file.name
  ```

  上面例子中，模式`*/`匹配目录部分，所以只返回文件名。

  下面再看一个例子。

  ```
  $ phone="555-456-1414"
  $ echo ${phone#*-}
  456-1414
  $ echo ${phone##*-}
  1414
  ```

  如果匹配不成功，则返回原始字符串。

  ```
  $ phone="555-456-1414"
  $ echo ${phone#444}
  555-456-1414
  ```

  上面例子中，原始字符串里面无法匹配模式`444`，所以原样返回。

  如果要将头部匹配的部分，替换成其他内容，采用下面的写法。

  ```
  # 模式必须出现在字符串的开头
  ${variable/#pattern/string}
  
  # 示例
  $ foo=JPG.JPG
  $ echo ${foo/#JPG/jpg}
  jpg.JPG
  ```

  上面例子中，被替换的`JPG`必须出现在字符串头部，所以返回`jpg.JPG`。

  **（2）字符串尾部的模式匹配。**

  以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。

  ```
  # 如果 pattern 匹配变量 variable 的结尾，
  # 删除最短匹配（非贪婪匹配）的部分，返回剩余部分
  ${variable%pattern}
  
  # 如果 pattern 匹配变量 variable 的结尾，
  # 删除最长匹配（贪婪匹配）的部分，返回剩余部分
  ${variable%%pattern}
  ```

  上面两种语法会删除变量字符串结尾的匹配部分（将其替换为空），返回剩下的部分。区别是一个是最短匹配（又称非贪婪匹配），另一个是最长匹配（又称贪婪匹配）。

  ```
  $ path=/home/cam/book/long.file.name
  
  $ echo ${path%.*}
  /home/cam/book/long.file
  
  $ echo ${path%%.*}
  /home/cam/book/long
  ```

  上面例子中，匹配模式是`.*`，其中`*`可以匹配任意数量的字符，所以最短匹配是`.name`，最长匹配是`.file.name`。

  下面写法可以删除路径的文件名部分，只留下目录部分。

  ```
  $ path=/home/cam/book/long.file.name
  
  $ echo ${path%/*}
  /home/cam/book
  ```

  上面例子中，模式`/*`匹配文件名部分，所以只返回目录部分。

  下面的写法可以替换文件的后缀名。

  ```
  $ file=foo.png
  $ echo ${file%.png}.jpg
  foo.jpg
  ```

  上面的例子将文件的后缀名，从`.png`改成了`.jpg`。

  下面再看一个例子。

  ```
  $ phone="555-456-1414"
  $ echo ${phone%-*}
  555-456
  $ echo ${phone%%-*}
  555
  ```

  如果匹配不成功，则返回原始字符串。

  如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。

  ```
  # 模式必须出现在字符串的结尾
  ${variable/%pattern/string}
  
  # 示例
  $ foo=JPG.JPG
  $ echo ${foo/%JPG/jpg}
  JPG.jpg
  ```

  上面例子中，被替换的`JPG`必须出现在字符串尾部，所以返回`JPG.jpg`。

  **（3）任意位置的模式匹配。**

  以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。

  ```
  # 如果 pattern 匹配变量 variable 的一部分，
  # 最长匹配（贪婪匹配）的那部分被 string 替换，但仅替换第一个匹配
  ${variable/pattern/string}
  
  # 如果 pattern 匹配变量 variable 的一部分，
  # 最长匹配（贪婪匹配）的那部分被 string 替换，所有匹配都替换
  ${variable//pattern/string}
  ```

  上面两种语法都是最长匹配（贪婪匹配）下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。

  ```
  $ path=/home/cam/foo/foo.name
  
  $ echo ${path/foo/bar}
  /home/cam/bar/foo.name
  
  $ echo ${path//foo/bar}
  /home/cam/bar/bar.name
  ```

  上面例子中，前一个命令只替换了第一个`foo`，后一个命令将两个`foo`都替换了。

  下面的例子将分隔符从`:`换成换行符。

  ```
  $ echo -e ${PATH//:/'\n'}
  /usr/local/bin
  /usr/bin
  /bin
  ...
  ```

  上面例子中，`echo`命令的`-e`参数，表示将替换后的字符串的`\n`字符，解释为换行符。

  模式部分可以使用通配符。

  ```
  $ phone="555-456-1414"
  $ echo ${phone/5?4/-}
  55-56-1414
  ```

  上面的例子将`5-4`替换成`-`。

  如果省略了`string`部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。

  ```
  $ path=/home/cam/foo/foo.name
  
  $ echo ${path/.*/}
  /home/cam/foo/foo
  ```

  上面例子中，第二个斜杠后面的`string`部分省略了，所以模式`.*`匹配的部分`.name`被删除后返回。

  前面提到过，这个语法还有两种扩展形式。

  ```bash
  # 模式必须出现在字符串的开头
  ${variable/#pattern/string}
  
  # 模式必须出现在字符串的结尾
  ${variable/%pattern/string}
  ```

- #### 改变大小写

  下面的语法可以改变变量的大小写。

  ```
  # 转为大写
  ${varname^^}
  
  # 转为小写
  ${varname,,}
  ```

  下面是一个例子。

  ```bash
  $ foo=heLLo
  $ echo ${foo^^}
  HELLO
  $ echo ${foo,,}
  hello
  ```

## 算数运算

- #### 算术表达式

  `((...))`语法可以进行整数的算术运算。

  ```
  $ ((foo = 5 + 5))
  $ echo $foo
  10
  ```

  `((...))`会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。

  ```
  $ ((2+2))
  $ (( 2+2 ))
  $ (( 2 + 2 ))
  ```

  这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是`0`，命令就算执行成功。

  ```
  $ (( 3 + 2 ))
  $ echo $?
  0
  ```

  上面例子中，`3 + 2`的结果是5，命令就算执行成功，环境变量`$?`为`0`。

  如果算术结果为`0`，命令就算执行失败。

  ```
  $ (( 3 - 3 ))
  $ echo $?
  1
  ```

  上面例子中，`3 - 3`的结果是`0`，环境变量`$?`为`1`，表示命令执行失败。

  如果要读取算术运算的结果，需要在`((...))`前面加上美元符号`$((...))`，使其变成算术表达式，返回算术运算的值。

  ```
  $ echo $((2 + 2))
  4
  ```

  `((...))`语法支持的算术运算符如下。

  - `+`：加法
  - `-`：减法
  - `*`：乘法
  - `/`：除法（整除）
  - `%`：余数
  - `**`：指数
  - `++`：自增运算（前缀或后缀）
  - `--`：自减运算（前缀或后缀）

  注意，除法运算符的返回结果总是整数，比如`5`除以`2`，得到的结果是`2`，而不是`2.5`。

  ```
  $ echo $((5 / 2))
  2
  ```

  `++`和`--`这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。

  ```
  $ i=0
  $ echo $i
  0
  $ echo $((i++))
  0
  $ echo $i
  1
  $ echo $((++i))
  2
  $ echo $i
  2
  ```

  上面例子中，`++`作为后缀是先返回值，执行`echo`命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行`echo`命令。

  `$((...))`内部可以用圆括号改变运算顺序。

  ```
  $ echo $(( (2 + 3) * 4 ))
  20
  ```

  上面例子中，内部的圆括号让加法先于乘法执行。

  `$((...))`结构可以嵌套。

  ```
  $ echo $(((5**2) * 3))
  75
  # 等同于
  $ echo $(($((5**2)) * 3))
  75
  ```

  这个语法只能计算整数，否则会报错。

  ```
  # 报错
  $ echo $((1.5 + 1))
  bash: 语法错误
  ```

  `$((...))`的圆括号之中，不需要在变量名之前加上`$`，不过加上也不报错。

  ```
  $ number=2
  $ echo $(($number + 1))
  3
  ```

  上面例子中，变量`number`前面有没有美元符号，结果都是一样的。

  如果在`$((...))`里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。

  ```
  $ echo $(( "hello" + 2))
  2
  $ echo $(( "hello" * 2))
  0
  ```

  上面例子中，`"hello"`会被当作变量名，返回空值，而`$((...))`会将空值当作`0`，所以乘法的运算结果就是`0`。同理，如果`$((...))`里面使用不存在的变量，也会当作`0`处理。

  如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在`$((...))`里面会被当作空值。

  ```
  $ foo=hello
  $ echo $(( foo + 2))
  2
  ```

  上面例子中，变量`foo`的值是`hello`，而`hello`也会被看作变量名。这使得有可能写出动态替换的代码。

  ```
  $ foo=hello
  $ hello=3
  $ echo $(( foo + 2 ))
  5
  ```

  上面代码中，`foo + 2`取决于变量`hello`的值。

  最后，`$[...]`是以前的语法，也可以做整数运算，不建议使用。

  ```bash
  $ echo $[2+2]
  4
  ```

- #### 数值的进制

  Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。

  - `number`：没有任何特殊表示法的数字是十进制数（以10为底）。
  - `0number`：八进制数。
  - `0xnumber`：十六进制数。
  - `base#number`：`base`进制的数。

  下面是一些例子。

  ```
  $ echo $((0xff))
  255
  $ echo $((2#11111111))
  255
  ```

  上面例子中，`0xff`是十六进制数，`2#11111111`是二进制数。

- #### 位运算

  `$((...))`支持以下的二进制位运算符。

  - `<<`：位左移运算，把一个数字的所有位向左移动指定的位。
  - `>>`：位右移运算，把一个数字的所有位向右移动指定的位。
  - `&`：位的“与”运算，对两个数字的所有位执行一个`AND`操作。
  - `|`：位的“或”运算，对两个数字的所有位执行一个`OR`操作。
  - `~`：位的“否”运算，对一个数字的所有位取反。
  - `^`：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。

  下面是右移运算符`>>`的例子。

  ```
  $ echo $((16>>2))
  4
  ```

  下面是左移运算符`<<`的例子。

  ```
  $ echo $((16<<2))
  64
  ```

  下面是`17`（二进制`10001`）和`3`（二进制`11`）的各种二进制运算的结果。

  ```bash
  $ echo $((17&3))
  1
  $ echo $((17|3))
  19
  $ echo $((17^3))
  18
  ```

- #### 逻辑运算

  `$((...))`支持以下的逻辑运算符。

  - `<`：小于
  - `>`：大于
  - `<=`：小于或相等
  - `>=`：大于或相等
  - `==`：相等
  - `!=`：不相等
  - `&&`：逻辑与
  - `||`：逻辑或
  - `!`：逻辑否
  - `expr1?expr2:expr3`：三元条件运算符。若表达式`expr1`的计算结果为非零值（算术真），则执行表达式`expr2`，否则执行表达式`expr3`。

  如果逻辑表达式为真，返回`1`，否则返回`0`。

  ```
  $ echo $((3 > 2))
  1
  $ echo $(( (3 > 2) || (4 <= 1) ))
  1
  ```

  三元运算符执行一个单独的逻辑测试。它用起来类似于`if/then/else`语句。

  ```
  $ a=0
  $ echo $((a<1 ? 1 : 0))
  1
  $ echo $((a>1 ? 1 : 0))
  0
  ```

  上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。

- #### 赋值运算

  算术表达式`$((...))`可以执行赋值运算。

  ```
  $ echo $((a=1))
  1
  $ echo $a
  1
  ```

  上面例子中，`a=1`对变量`a`进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。

  `$((...))`支持的赋值运算符，有以下这些。

  - `parameter = value`：简单赋值。
  - `parameter += value`：等价于`parameter = parameter + value`。
  - `parameter -= value`：等价于`parameter = parameter – value`。
  - `parameter *= value`：等价于`parameter = parameter * value`。
  - `parameter /= value`：等价于`parameter = parameter / value`。
  - `parameter %= value`：等价于`parameter = parameter % value`。
  - `parameter <<= value`：等价于`parameter = parameter << value`。
  - `parameter >>= value`：等价于`parameter = parameter >> value`。
  - `parameter &= value`：等价于`parameter = parameter & value`。
  - `parameter |= value`：等价于`parameter = parameter | value`。
  - `parameter ^= value`：等价于`parameter = parameter ^ value`。

  下面是一个例子。

  ```
  $ foo=5
  $ echo $((foo*=2))
  10
  ```

  如果在表达式内部赋值，可以放在圆括号中，否则会报错。

  ```bash
  $ echo $(( a<1 ? (a+=1) : (a-=1) ))
  ```

- #### 求值运算

  逗号`,`在`$((...))`内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。

  ```
  $ echo $((foo = 1 + 2, 3 * 4))
  12
  $ echo $foo
  3
  ```

  上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值`12`。

- #### expr 命令

  `expr`命令支持算术运算，可以不使用`((...))`语法。

  ```
  $ expr 3 + 2
  5
  ```

  `expr`命令支持变量替换。

  ```
  $ foo=3
  $ expr $foo + 2
  5
  ```

  `expr`命令也不支持非整数参数。

  ```
  $ expr 3.5 + 2
  expr: 非整数参数
  ```

  上面例子中，如果有非整数的运算，`expr`命令就报错了。

- #### let 命令

  `let`命令用于将算术运算的结果，赋予一个变量。

  ```
  $ let x=2+3
  $ echo $x
  5
  ```

  上面例子中，变量`x`等于`2+3`的运算结果。

  注意，`x=2+3`这个式子里面不能有空格，否则会报错。`let`命令的详细用法参见《变量》一章。

------

