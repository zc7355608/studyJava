# Vue

------

> Vue是一套用于，构建用户界面的，渐进式JS框架。简单来说就是负责将AJAX取来的数据渲染到HTML页面上的JS框架。
>
> 那什么是渐进式呢？就是，Vue可以自底向上逐层的应用。简单应用只需要一个清凉小巧的Vue核心库；复杂应用可以引入各种的Vue插件。
>
> Vue的特点：
>
> - 采用**组件化**模式，提高代码复用率、且让代码更好维护。它是指，Vue将页面中的某一个板块的所有样式、css、js都封装为一个`.vue`结尾的文件，这样用的话直接引入该文件，修改内部的css、html代码即可。
> - **声明式**编码，让编码人员无需直接操作DOM，提高开发效率。它是指，页面中使用特殊的属性和标记，来完成特定的效果，无需我们做编写复杂的JS代码就可以实现，有点类似JSP。
> - 使用**虚拟DOM**和优秀的Diff算法，尽量**复用DOM节点**。
>
> 准备工作：下载`vue.js`文件引入到HTML，下载Vue的开发者工具（crx文件），拖到浏览器的扩展中心即可。

- ### 第一个Vue程序：

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 引入vue文件后，类似于jQuery，全局中多了一个构造函数Vue() -->
    <script src="./js/vue.js"></script>
    <!-- vue的全局配置 -->
    <script>
      Vue.config.productionTip = false
    </script>
    <title>test Vue</title>
  </head>
  <body>
  <!-- 准备好一个容器。因为vue采用组件化模式，要将vue的组件放在页面的指定位置上，所以用div包住指定位置 -->
    <div id="root">
      <!-- 先写死 -->
      <!-- <h1>Hello,Vue!</h1> -->
      <!-- 这里面的代码依旧用HTML，只是加入了vue的语法。容器中的代码被称为【Vue模板】 -->
      <h1>Hello,{{user}}!</h1><!-- 这是vue模板的插值语法，里面可以写data对象的属性，或者JS表达式 -->
    </div>
    <script>
      //想让Vue工作，就必须创建对应的Vue实例，传进去配置对象
  	const v = new Vue({
        //vue实例要将组件内容放在这个标签内部。值通常为css选择器串，还可以是dom对象
        el: '#root',
  	  //data中用于存储数据，数据供el指定的容器中使用，值目前先用对象
        data: { user: '尚硅谷' }//一般该对象中只出现属性不出现方法，方法一般不在这儿写
      })
      //修改user中的数据，页面也随之更新，这就是vue的响应式，它会对数据进行监测
      v.user = '尚学堂'
    </script>
  </body>
  </html>
  ```

- ### 第一个程序的细节：

  > - HTML容器和Vue实例之间是**1对1关系**。它会从上到下找第1个符合条件的去接管。（Vue实例还可以有多个子实例（组件实例对象）去接管容器内部的不同部分）
  > - `vue模版`中，`{{}}`中写JS表达式时，表达式中的函数或属性，都要是vue对象上的，vue对象上没有的不行。vue对象上有的属性，都可以在**vue模板**中直接使用。
  > - `data`中的任何数据只要发生变化，**vue模板**会被重新解析渲染。（Vue的响应式）
  > - vue实例对象中有两种属性，一种是以`$`开头的，这些都是vue供我们用的。剩下的都是vue内部的底层代码用的，一般不用管。
  > - **重要**：vue首先对data对象中的数据做了增强，生成了代理对象，vue对象的`_data`指向了该代理对象。
  >   - data中的属性在vue对象上也可以找到。实际上vue对象上的这些属性都是虚拟属性，是通过`Object.defineProperty()`方法的getter和setter加的，访问和修改的都是`_data`中代理对象的数据。
  >
  >   - 代理对象的对应属性也是虚拟属性。vue首先拿到data中的数据，为其中的数据生成getter和setter（虚拟属性）。对`_data`中的数据的访问和修改，最终访问修改的都是data的数据。
  >
  >   - 所以只要`_data`中数据发生了变化，实际上修改的是data中的原始数据；访问`_data`实际上访问的是data中的原始数据。这就是vue对data做的**数据代理**。`_data`实际上是data对象的代理对象。
  >

------

- ## Vue模板的语法

  - ### 插值语法：

    > 如果是**标签体内容**要实现动态化，就需要用插值语法，用`{{}}`将JS表达式包起来。

  - ### 指令语法：

    > - 如果是**标签属性**要实现动态化，需要用指令语法。其中的一个`v-bind`指令：`v-bind:属性名='js表达式'`，可以实现属性的动态化。（有点像`Thymeleaf`中的`th:属性名="${域中的数据}"`）
    >
    > - 并且由于`v-bind:属性名='js表达式'`很常用，所以**可以简写**为`:属性名='js表达式'`
    >
    >
    > （指令语法主要用于**解析标签**，形式都是`v-xxx`，可以解析标签属性、标签体内容、绑定事件等....）

- ## Vue的数据绑定

  > - 其实`v-bind`指令就是一个数据绑定指令，当data中的数据发生了变化，那么对应的属性值就会变，它是单向的数据绑定指令。
  >
  > - 而`v-model`指令则是双向的数据绑定，属性值发生变化，对应的data中的数据也会变化。但是注意：它只能用在**有value属性的元素**上，并且`v-model:value='js表达式'`可以简写为`v-model='js表达式'`，因为它一般绑定的都是`value`属性。

- ## el和data属性的另一种写法

  > - 声明vue对象可以不指定el属性，用vue对象的`$mount()`实例方法，也可以将vue对象和容器进行1对1绑定：`v.$mount('#root')`，这种方式更灵活。`$mount()`是将容器挂载到vue对象上。
  >
  > - `data`属性的函数式写法，要求函数的返回值必须是1个对象：（一个原则：**vue所管理的函数一定不要用箭头函数**）
  >
  >   ```js
  >   const v = new Vue({
  >       el: '#root',
  >       data(){//完整形式为，data:function(){}
  >           console.log(this)//this是当前vue对象
  >           return { user: '张三' }
  >       }
  >   })
  >   ```

------

- ## MVVM模型

  > Vue的设计一定程度上参考了MVVM模型。MVVM是指：
  >
  > - M：模型（Model），对应data中的数据，是一般的JS对象
  > - V：视图（View），Vue关联的容器
  > - VM：视图模型（ViewModel），对应Vue实例对象（因此vue实例通常叫vm）
  >
  > ![20200204123438](./assets/20200204123438.png)

------

- ## 事件处理

  - ### 给元素绑定事件：

    > - 通过指令`v-on:事件名称='表达式'`（简写为：`@事件名称='表达式'`），可以给元素绑定事件，然后在vue对象的配置里加`methods: {函数}`，里面是需要vue对象在事件发生时去调用的函数（被vue对象管理的函数，不要用箭头函数），最终这些函数会出现在vue对象上（所以也可以在vue模版中被调用）
    > - 表达式中的函数调用可以加小括号`()`传参，默认会传事件对象，`$event`是形参的占位符，可以放在任何位置来接收事件对象，避免传参后事件对象消失。（JS中直接在元素上绑定函数的形参是不能传参的）
    > - 和`data`中的数据不同的是，`methods`中的数据vue不会做数据代理。因为函数不会修改，所以不用做响应式。所以通常`data`中写经常变的属性数据，`methods`中写不会变的方法、函数等数据。
  
  - ### 事件修饰符：
  
    > - 可以在事件名称后面加事件修饰符，来控制事件相关的属性，如：`v-on:click.prevent='表达式'`，常见的事件修饰符有：（可以连着写：`@click.stop.prevent='表达式'`，注意顺序）
    >
    >   - `prevent`（常用）：阻止事件的默认行为，只执行表达式，默认的跳转、提交等行为不执行。
    >
    >   - `stop`（常用）：阻止事件冒泡。
    >
    >   - `once`（常用）：事件只触发一次，之后的事件发生也不会执行后面的表达式。
    >
    >   - `capture`：捕获该事件，等处理完后事件流再往下走。
    >
    >   - `self`：只有`event.target`是当前元素才执行表达式，也就是流过来的事件不触发表达式的执行。
    >
    >   - `passive`：先执行事件的默认行为，再执行表达式。
    >
    > - 键盘事件的事件修饰符：（`@keydown.enter='表达式'`）
    >   - `enter`：按下的是回车键才执行表达式
    >   - `delete`：退格和删除键都能触发
    >   - `esc`：ESC键
    >   - `space`：空格
    >   - `tab`：制表（特殊，必须是keydown）
    >   - `caps-lock`：大小写，2个单词的键需要用这种格式
    >   - `up`：上箭头
    >   - `down`：下箭头
    >   - `left`：左箭头
    >   - `right`：右箭头
    >   - 几个特殊的系统修饰键（Ctrl、Alt、Shift、win键），它们的使用：
    >     1. 配合keyup：按下修饰键的同时，再按下任意其他键，随后释放其他键，事件才会触发。也可以指定按下y键才触发：`@keyup.ctrl.y='表达式'`
    >     2. 配合keydown：正常触发
    > - v-model指令的事件修饰符：
    >   - `number`：可以将输入的value值转为数值型，如：`v-model.number='age'`，此时会将收集到的value值给age变量，值是Number类型的。
    >   - `lazy`：失去焦点时再进行数据收集。不设置的话是实时收集，value值变一次就收集一次。
    >   - `trim`：收集的value数据去掉前后空格。

------

- ## 计算属性（computed）

  > vue模板内的可以使用表达式很不错，可以将取到的数据做运算和操作，但是设计它们的初衷是用于简单运算的，如果在模板中放入太多的复杂的逻辑会让模板过重且难以维护。所以，对于任何复杂的逻辑，都应当使用**计算属性**，使用：
  >
  > ```js
  > const v = new Vue({
  >     el: '#root',
  >     data(){
  >     	name: '张三'
  >     },
  >     //通过computed来指定计算属性
  >     computed: {
  >         fullname: {
  >         	//当读计算属性fullname时，get()方法就会被vue对象调用，返回值是属性fullname的值。它也在vue对象上
  >         	get(){ return '我是'+ this.name },//get方法中的this就是vue对象
  >         	//当fullname被修改时，set()方法会被vue对象调用。如果你确定该属性不会被改，那就不用写set
  >         	set(v){ this.name = v }
  >         }
  >     }
  > })
  > ```
  >
  > - 计算属性和普通属性一样，可以通过vue实例对象访问。
  >
  > - 计算属性本身不存在，要通过已有的vue实例的属性计算得来。底层是通过`Object.defineProperty()`方法的`get`和`set`方法。
  >
  > - 计算属性被推荐的原因是，它的值会被vue缓存。只有**初次读取计算属性**，或**get()所依赖的数据发生了变化**时，get()才会被调用。所以它的效率较高。
  >
  > - 计算属性也可以简写。当确定了计算属性只读不改，不需要`set()`时，可以：`fullname: function(){}`

- ## 监视属性（watch）

  > 它会在该属性发生变化时调用对应的`handler()`方法，计算属性也可以监视。使用：

  ```js
  const v = new Vue({
      el: '#root',
      data(){
      	name: '张三'
      },
      watch: {
          //监视name属性，属性没有也不会报错
          name: {
              immediate: true,//该属性初始化时就调用1次handler，默认false初始化时不调用
              handler(niu,old){
                  console.log('name被改了',niu,old)
              }
          }
      }
  })
  ```

  > - 另一种写法：`vm.$watch('name',{})`，这种更灵活
  > - 如果监视的属性是一个对象，对象中还有属性，那么要监视的属性就得写成**字符串形式**：`'name.first'`
  > - 默认watch不会进行深度监视，深度监视不会调用函数。开启的话：`deep: true`
  > - 如果监视的属性的配置中只有`handler()`，没有其他配置，那么可以简写：`name(niu,old){}`，当然另一种写法也可以简写：`vm.$watch('name',function(niu,old){})`（注意vue管理的函数不要用箭头函数）

- ## 计算属性和监视属性的区别

  > - `computed`计算属性能完成的任务，`watch`监视属性都能完成。但是`watch`监视属性能完成异步任务，`computed`计算属性不行。
  >  - `computed`计算属性用的较多且代码写起来简单，但是计算属性要依靠`return`将值返回，所以如果是异步任务它就处理不了了。
  >   - `watch`监视属性不依赖返回值，它是亲自处理的数据，可以处理异步任务。
  > 
  > - 注意：所有**被vue管理的函数，要用普通函数的写法**，这样`this`才是vue实例或**组件实例对象**。而不被vue管理的函数（AJAX、Promise、定时器），推荐用箭头函数的写法，这样this指向的还是vue对象。

- ## 样式的设置

  > vue中也可以动态设置CSS样式，分为两种情况，动态设置类名和动态设置行内样式：

  - ### 动态设置类名：（3种方式）

    > 通过`v-bind:class`来动态设置class属性，如：`:class='表达式'`。表达式的值一般有以下3种：
    >
    > 1. 变量。如：`:class='mood'`，此时会去vue对象上找mood属性（普通String型），用该属性的值来给class属性上**追加**类名。适用于**当某个类名需要动态变化时**。
    > 2. 数组。如：`:class="['happy','sad','alone']"`，此时数组中的类名都是动态的，可以通过往数组中添加和删除元素来管理元素上的多个类名。适用于**要绑定的类名的个数、名字都不确定时**。
    > 3. 对象。如：`:class="{happy: false; sad: true}"`，表示加上sad类名，去掉happy类名。适用于**启用某个类名时**

  - ### 动态设置行内样式：

    > 通过`v-bind:style`来动态设置style属性，如：`:style='表达式'`。表达式的值一般有以下2种：
    >
    > 1. 对象。**样式对象**的属性名是CSS的属性名，再改成用小驼峰形式，如：`:style='obj'`，data中的数据：
    >
    >    ```js
    >    data: {
    >    	obj: {
    >    		fontSize: '16px',
    >    		color: 'red',
    >    		backgroundColor: 'orange'
    >    	}
    >    }
    >    ```
    >
    > 2. 数组。里面是多个样式对象，如：`:style='[obj1, obj2]'`，这样obj1和obj2对象中的CSS样式都会以行内样式加入。

- ## 条件渲染

  > 条件渲染对应着不同的指令，当满足某些条件时，就给元素加上某些CSS样式。

  - `v-show`：表达式的值为true时就显示，否则隐藏。它相当于设置了`display: true;`，DOM还在HTML中，只是隐藏了。

  - `v-if`：表达式的值为true时，HTML文档中就有该元素。它是动态的增删HTML节点。对应的还有`v-else`、`v-else-if`，如：

    ```html
    <h1 v-if="awesome">Vue is awesome!</h1>
    <h1 v-else-if="shit">Vue is shit!</h1>
    <h1 v-else>Oh no 😢</h1>
    ```

    > 注意：以上3个标签需要紧紧地挨在一起才能达到if语句的效果。

    > （了解）v-if和template标签的配合使用：（相当于其中的3个标签上都加了v-if属性，满足条件时一块渲染，template不会影响结构）
    >
    > ```html
    > <template v-if="ok">
    > 	<h1>Title</h1>
    > 	<p>Paragraph 1</p>
    > 	<p>Paragraph 2</p>
    > </template>
    > ```

- ## 列表渲染

  > vue可以根据数据条数来动态生成多个标签元素，通过`v-for`指令。比如在<ul>中拼接多个<li>，语法：
  >
  > ```html
  > <ul>
  > <li v-for="p in persons" :key="p.id">
  >  	{{ p.name }}-{{ p.age }}
  > </li>
  > </ul>
  > <!-- 其实有两个参数，第2个参数是下标。of也可以 -->
  > <!-- <li v-for="(p,index) of persons" :key="index"> -->
  > ```
  >

  - 该指令加到哪个标签上，哪个标签就会渲染多个，很像`for in`遍历对象的语法。

  - 遍历的属性可以是vue对象上的数组、对象、字符串、数值。对象的参数为：`(value,key)`，字符串的参数为字符和下标：`(char,index)`，数值的参数为次数和下标：`(num,index)`

  - 这多个一模一样的标签，vue建议我们：**一定要给每一个标签加上不同的标识**，通过`:key="index"`（动态的key属性），这个动态的特殊的key属性，vue内部在维护，标签上没有。

  - 如果不写这个key属性，那么默认用下标index来当做key，这时候在某些情况下可能就会出现问题。原因是：

    > Vue、React中，标签上的key属性有什么作用？
    >
    > key是虚拟DOM的标识。当数据发生变化时，Vue会根据新数据生成新的虚拟DOM，随后用新虚拟DOM和旧的虚拟DOM，通过key进行对比（key只存在虚拟DOM上，真实DOM上没有该属性）。比较规则：
    >
    > - 如果新DOM中key在旧DOM中存在。那么再看DOM中的子DOM变了没：如果没变，那么该虚拟DOM映射成真实DOM时，还用原来的；如果哪个子DOM变了，则生成新的子DOM替换旧的子DOM，映射为真实DOM进行替换。
    > - 如果不存在，那么就创建新的DOM映射为页面上的真实DOM。

  - 所以使用index做为key，当**对数据进行逆序添加，逆序删除等破坏顺序的操作**，就会产生没有必要的DOM更新。如果此时结构中还有输入类的DOM，会产生错误的DOM更新，页面会出问题。

  - 开发中如何选择key？最好使用每一条数据的唯一标识，如：id、手机号、身份证等数据库中的唯一值。

  - 如果不存在对数据进行逆序添加、逆序删除等破坏原有顺序的操作，只是展示数据，那么用index做为key也是可以的。

- ## Vue的响应式

  > - 只有刚开始就写在vue对象的data中的属性，vue才会对其做响应式，后面再往data上添加的属性，vue都不会做响应式了。
  > - 可以通过Vue提供的API给data添加属性，这样vue会对它做数据代理和响应式：`Vue.set(targetObj, 属性名, 值)`，它和`vm.$set()`是一样的。返回值是添加的值。
  > - 该API有局限性，就是：**不能直接在vue对象或data对象上添加**（往data中的对象上添加属性可以）。

  > - 当通过下标的方式，对data中的数组数据进行修改时，vue是无法监测到的。因为vue并没有对数组中每个元素提供getter和setter进行数据代理，所以这种方式修改数组vue是不知道的。
  > - 只有我们通过：`push()、pop()、shift()、unshift()、splice()、sort()、reverse()`，这些会影响原始数组数据的方法，来修改数组时vue才知道。vue是怎么知道，我们调用了数组对象的这几个方法呢？是这样：vue对这几个方法做了包装。也就是说这几个方法都是vue重写的方法，不是Array原型对象上的方法了。
  > - 在vue封装的方法中，首先调用了原先的push、pop等方法，完成正常的功能；然后vue去重新解析了模版，进而更新页面。
  > - 也可以用`Vue.set('vm.student.hobby', 1, '游泳')`，来用下标对数组进行修改。

- ## 表单数据的收集

  > - 多选框：只有配置了value属性，且每个多选框的`v-model='arr'`绑定的数据都是同一个数组，那么收集的是value组成的数组。其他情况下多选框收集的数据都是true和false是否勾选。

- ## 过滤器

  > 过滤器是vue提供的一个新的数据处理的方式而已，可以对你的数据进行一道道加工，你可以选择用或不用。语法：

  > 过滤器只能在**插值语法`{{}}`**或`v-bind:属性名=''`中使用，如：`{{ time | timeFormat }}`，然后在vue对象中定义过滤器：
  >
  > ```js
  > const v = new Vue({
  >     el: '#root',
  >     data(){
  >     	time: 124134314134313
  >     },
  >     filters: {
  >         //过滤器的本质就是函数
  >         timeFormat(v){
  >             return dayjs(v).format('yyyy-MM-dd: HH:mm:SSS')
  >         }
  >     }
  > })
  > ```
  >
  > - vue会将管道符`|`前面的time做为参数，传给过滤器timeFormat函数并调用，过滤器的返回值做为插值语法中整个JS表达式的结果。
  > - 过滤器也可以传递参数，传递的参数做为过滤器函数的第2、3...个参数，过滤器的第1个参数永远是管道符前面的值。
  > - 类似于Linux的管道操作，多个过滤器也可以串联。
  > - 这种方式的过滤器是局部的，全局过滤器需要**在实例化vue对象之前**，通过vue的构造函数配置：`Vue.filter('timeFormat', function(v){过滤器函数})`

- ## Vue中其他的内置指令

  - `v-text`：向其所在的标签内部插入文本，它会将标签内部的所有内容全部替换。如：`v-text="name"`（类似于innerText）

  - `v-html`：类似于v-text，只是它能够识别文本内的HTML标签（类似于innerHTML）。注意：开发中通常不要在网站上动态渲染HTML结构，这种方式是非常危险的，容易导致XSS攻击。

  - `v-clock`（没有值）：该指令就是标签中的一个特殊的属性，vue对象在创建并接管容器后，会删掉该属性。它的使用场景：

    > 使用CSS配合v-clock可以解决网速慢时页面展示出未经过vue渲染的`{{xxx}}`的问题：
    >
    > 我们通常在vue的根容器上加上该属性，并在style中设置`[v-clock] {display:none;}`，这样在vue接管该容器之前，这个容器是不会展示在页面上的。

  - `v-once`（没有值）：该指令所在节点在初次动态渲染后，就视为静态内容了。以后数据的改变它不会再渲染了，用于优化性能。

  - `v-pre`（没有值）：该指令可以让vue，跳过对其所在节点（及其子节点）的渲染。没有用vue语法的节点加上该属性可以加快编译。
  
  - 自定义指令：

- ## Vue的生命周期
