<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>监听属性watch</title>
    <script src="../js/vue.js"></script>
</head>
<body>
    <div id="app">
        <h1>{{msg}}</h1>
        <h1>{{a.b}}</h1>
    </div>
    <script>
        const vm = new Vue({
            el : '#app',
            data : {
                msg : 'watch配置项监听属性的变化',
                'a' : {
                    b : 'b',
                    c : 'c'
                }
            },
            computed : {
                change(){
                    return this.msg +"change"
                }
            },
            watch : {
                //监视哪个属性，就拿过来即可
                msg : {
                    //深度监视
                    // deep : true,
                    //这个配置为true表示初始化时就调用一次handle，虽然属性没变
                    immediate : true,
                    //默认的handler方法，当msg该属性发生变化时，就会调用handler方法，该方法有两个参数
                    handler(newValue, oldValue){
                        //this是当前的vm实例对象，如果是箭头函数，那么this是window对象
                        console.log(newValue, oldValue)
                    }
                }
                //如果希望监听某个属性内部的属性，那么就'a.b' : {}即可
                //如果监听的属性有多级结构，想都给它监视了，深度监视，那么加一个配置项deep:true就行了
                //当你监视的内容中只有handler时，可以简写：msg(newValue, oldValue){console.log(newValue, oldValue)}
            }
        })
/*
如果后期需要给某个属性加上监视的话：vm.$watch('被监视的属性名', {})即可
这是后期添加监视的简写形式：vm.$watch('被监视的属性名', function(newValue, oldValue){})
*/
/*
计算属性和监听属性如何选择呢？
    一般情况下，计算属性computed可以做到的监听属性watch同样可以完成，但是如果程序采用异步的方式，那就只能用监听属性watch了，因为它没有返回值
什么时候用箭头函数，什么时候用普通函数呢？
    如果是vue管理的函数就用普通函数，如果不是vue管理的函数就用箭头函数
*/
    </script>
</body>
</html>